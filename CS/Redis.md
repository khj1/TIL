# Redis (Remote Dictionary Server)
- 외부에 사전 형태로 저장하는 서버이다.
- 사전 형태란 key-value 구조를 뜻한다.
- 즉 Redis란 **메모리에 저장하는 Key-Value 기반의 NoSQL DBMS이다.** 
- Redis는 캐시의 구현 방법 중 하나다.

### Redis 용도
- 캐싱
- 임시 작업 큐
- 실시간 채팅
- 메시지 브로커

### Redis 특징
- **성능이 뛰어나다.**
- **다양한 자료 구조를 제공한다.** (개발의 편의성 증가)
  - Key는 주로 String 자료형을 사용한다.
  - Value에는 Hash, List, Sorted Set 등 다양한 자료구조를 사용할 수 있다.
- **싱글 쓰레드 방식을 사용한다.**
  - 한번에 하나의 명령만을 처리한다.
  - Race Condition이 거의 발생하지 않는다.
- **메모리에 저장된 데이터를 디스크에 영속화한다.**
  - 서버에 치명적인 문제가 발생해도 데이터를 복구할 수 있다.
  - Redis Persistence 옵션에는 RDB, AOF가 있다.

> **Race Condition이란?** <br />
> 두 개 이상의 프로세스, 쓰레드가 동시적으로 하나의 리소스에 접근하려 경쟁하는 상태를 의미한다.

> **RDB (Redis Database Backup)** <br />
> 특정한 간격으로 현재 Redis의 메모리에 존재하는 데이터의 스냅샷을 남기는 방식
> - 데이터를 압축해서 저장하기 때문에 AOF보다 크기가 작다. 
> - 로딩, 복구 속도가 빠르다.
> - 백업 중에 서버가 다운될 경우 최신 데이터가 유실될 가능성이 있다.

> **AOF (Append Only File)** <br />
> 입력, 수정, 삭제 명령이 실행될 때마다 Log 파일에 기록하는 방식
> - 저장 속도가 빠르다.
> - 실시간으로 데이터 백업이 가능하기 때문에 데이터 손실이 거의 없다.
> - 명령 실행을 모두 기록하기 때문에 파일 크기가 크다.
> - 데이터 자체를 저장하는 것이 아니기 때문에 복원 소요시간이 길다.

#### Java의 HashMap 같은 자료구조를 캐시 용도로 사용하면 안되는걸까?
- 서버가 여러대인 경우 Consistency 문제가 발생한다.
- 서버마다 캐시 메모리가 보유하고 있는 데이터가 서로 달라질 수 있다.
- 멀티 쓰레드 환경에서 Race Condition을 마주할 수 있다.

#### Redis는 이러한 문제들을 어떻게 해결할까?
- Redis는 싱글 쓰레드로 동작하여 Race Condition이 발생하지 않고
- Redis의 자료구조는 Atomic하게 설계되어 Critical Session에 대한 동기화를 제공한다.
- Redis는 서로 다른 Transaction의 Read와 Write를 동기화한다.

> **Critical Session이란?** <br />
> 동시에 여러 개의 프로세스가 접근하면 안되는 영역을 의미한다.

## Redis를 효과적으로 활용하는 방법
### 데이터 타입에 따라 적절한 자료구조를 사용한다.
- 최근 검색 목록을 표시하는 기능을 개발한다고 가정해보자.
- 중복을 허용하지 않고, 최근 5개의 검색 목록을 정렬해서 조회해야 한다.
- Redis의 Sorted Set 자료구조를 활용하면 로직 구현이 더 편해진다.
- Redis의 Sorted Set은 가중치를 기준으로 오름차순 정렬된다.

### O(N) 명령어 주의
- KEYS, FLUSHALL, FLUSHDB, Delete Collections, Get All Collections
- Redis는 싱글 쓰레드로 동작한다.
- 따라서 위와 같은 O(N) 명령어를 사용하면 해당 명령어가 처리될 때까지 다음 명령어들이 대기 상태로 전환되는 문제가 발생한다.
- Redis를 사용함으로써 오히려 성능이 저하될 수 있다.

> **O(N) 명령어란?** <br />
> 시간 복잡도가 O(N)인 명령어이다. 즉 데이터 수가 증가할 때마다 알고리즘 단계 수기 비례해서 증가하는 명령어를 의미한다.

### 메모리 관리
Redis는 메모리 특성상 메모리 단편화가 발생할 수 있다. 

따라서 RSS (Resident Set Size, 실제 물리 메모리 사용량)를 모니터링해서 메모리 관리를 해줘야할 필요가 있다.

#### 메모리 파편화란? (Memory Fragmentation)

![image](https://github.com/khj1/TIL/assets/74335027/f283c42f-46ef-41a3-ad2e-a428ba363b73)

메모리 단편화란 메모리가 작은 공간으로 나뉘어져 관리되어서 공간이 충분함에도 데이터를 할당하지 못하는 상황을 의미한다.

위 이미지에서 A와 C 오브젝트가 메모리에서 해제되었지만 하나의 큰 공간으로 합쳐지지 않았다. 따라서 해당 공간에는 이전에 해제된 객체와 동일하거나 더 작은 데이터만 할당될 수 있다.

파편화가 발생하면 실제로는 충분한 메모리 공간이 있음에도 필요한 크기의 연속적인 메모리 블록을 찾을 수 없어 메모리를 할당할 수 없는 경우가 생긴다.

> Java의 GC는 이러현 단편화된 메모리의 빈 공간을 압축하는 Compact 작업을 수행한다.

### Redis 목적성
- Redis를 사용할 떄는 어떤 용도로 Redis를 사용할 것인지 그 목적을 분명히 해둘 필요가 있다.
- Redis의 Persistence 옵션인 RDB, AOF는 장애 발생 가능성이 높은 것으로 알려져있다.
- 따라서 단순 캐시 용도로 Redis를 사용한다면 Persistence 기능을 사용하지 않는 것을 권장하고 있다.