# 컴포넌트 스캔과 의존 관계 자동 주입

지금까지 스프링 빈을 등록할 떄는 자바 코드의 `@Bean`이나 XML의 \<bean> 등을 통해서 설정 정보에 직접 등록할 스프링 빈을 나열했다.

하지만 등록할 스프링 빈이 수십, 수백개가 되면 일일이 등록하기도 귀찮고, 설정 정보도 커지고, 누락하는 문제도 발생한다. 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 **컴포넌트 스캔**이라는 기능을 제공한다.

또한 의존 관계도 자동으로 주입하는 `@Autowired`라는 기능도 제공한다.

### `@ComponentScan`

- `@ComponentScan`은 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록한다.
- 이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  - 빈 이름 기본 전략: `MemberServiceImple` 클래스 -> `memberServiceImpl`
  - 빈 이름 직접 지정: `@Component("memberService2")`

> **`@ComponentScan.Filter`**<br/>
> `excludeFilters = @ComponentScan.Filter(type = FilterType.{}, classes = {}.class)`

`@ComponentScan` 을 통해서 자동으로 스프링 빈으로 등록할 수 있다고 치자, 그렇다면 **의존 관계는 어떻게 주입할 수 있는가?**

### `@Autowired`

- 생성자에 `@Autowired`를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 이때 스프링 컨테이너는 클래스의 타입을 기준으로 탐색한다.
  - 해당 클래스의 부모 클래스와 자식 클래스에 해당하는 타입을 같은 클래스 타입이라고 판단한다.
  - `ac.getBean(MemberRepository.class)`


## 탐색 위치와 기본 스캔 대상

모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래걸린다. 그래서 꼭 필요한 위치 부터 탐색하도록 시작 위치를 지정할 수 있다.

```java
@ComponentScan (
	basePackages = "hello.core",
)
```

- `basePackages`
  - 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
  - `basePackages = {"hello.core", "hello.service"}` 이렇게 여러 시작 위치를 지정할 수도 있다.
- `basePackageClasses`
  - 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
- 만약 **지정하지 않으면(default)** `@ComponentScan`이 붙은 <u>설정 정보 클래스의 패키지가 시작 위치가 된다.</u>

### 권장하는 방법

패키지 탐색 위치를 지정하지 않고, **설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것**이다.

스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 `@SpringBootApplication` 를 프로젝트 시작 루트 위치에 두는 것이 관례이다.
- 이 설정안에 바로 `@ComponentScan` 이 포함되어 있다.

### 컴포넌트 스캔 기본 대상 및 추가 기능

컴포넌트 스캔은 `@Component`뿐만 아니라 다음과 같은 내용도 추가 대상에 포함한다.

- `@Controller` : 스프링 MVC 컨트롤러에서 사용
- `@Repository` : 스프링 데이터 접근 계층에서 사용
  - **데이터 계층의 예외를 스프링 예외로 변환해준다.**(추상화)
    - A DB를 사용하다가 B DB를 사용하게 됐을 때 서로 발생하는 예외가 상이할 수 있다.
    - 이런 상황에서 비즈니스 로직이 흔들리지 않도록 특정 예외를 스프링 예외로 추상화 시켜준다.
  - DB가 변하면 예외 내용도 변하기 때문에 비즈니스 로직에서의 예외 관련 코드를 수정할 일 없도록 해준다.
- `@Configuration` : 스프링 설정 정보에서 사용한다.
  - 스프링 빈이 싱글톤을 유지할 수 있도록 추가 처리를 한다.(CGLIB)
- `@Service` : 스프링 비즈니스 로직에서 사용
  - 특별한 별도의 기능을 수행하진 않는다.
  - 비즈니스 로직이 담긴 클래스구나 라는 것을 인식하기 용이하도록 만들어준다.

> **참고** <br/>
> 사실 어노테이션에는 상속 관계라는 것이 없다. 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, **스프링이 지원하는 기능**이다.

## 컴포턴트 스캔 필터

- `includeFilter`: 스캔 대상을 추가로 지정
- `excludeFilter`: 스캔에서 제외할 대상 지정

### `FilterType` 옵션

- `FilterType.ANNOTATION`: 기본값, 어노테이션을 인식해서 동작
- `FilterType.ASSIGNABLE_TYPE`: 지정한 타입과 자식 타입을 인식해서 동작
- `FilterType.ASPECTJ`: AspectJ 패턴을 사용한다
- `FilterType.REGEX`: 정규 표현식
- `FilterType.CUSTOM`: `TypeFilter` 라는 인터페이스를 구현해서 처리한다.

`@Component` 를 사용하기 때문에 `includeFilter` 는 사용할 일이 거의 없다.

## 중복 등록과 충돌

### 자동 빈 등록 vs 자동 빈 등록

등록된 스프링 빈의 이름이 서로 같을 경우 오류가 발생한다.
- `ConfilctBeanDefinitionException`

자동 빈 등록으로 인해 충돌이 발생하는 경우는 거의 없다.

### 수동 빈 등록 vs 자동 빈 등록

수동 등록 빈과 자동 등록 빈의 이름이 같을 경우 **수동 등록 빈이 우선한다.**

그러나 개발자가 의도적으로 수동 등록 빈과 자동 등록 빈의 이름을 동일하게 설정할 이유가 거의 없다. 대부분 잘못된 설정 정보로 인해 애매한 버그가 발생하는 것이다.

최근 스프링 부트 버전은 수동 등록 빈과 자동 등록 빈이 충돌 시 오류를 발생시킨다.
