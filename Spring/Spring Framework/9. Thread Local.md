# 쓰레드 로컬

**해당 쓰레드만 접근할 수 있는 특별한 저장소를 의미한다.**

예를 들어 물건 보관 창구를 떠올리면 된다. 여러 사람이 같은 물건 보관소를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.

## 필요성

싱글톤 객체를 사용하면 한정된 자원을 효과적으로 사용할 수 있다. 하지만 **싱글톤 객체가 가변 필드를 갖고 있다면 동시성 문제가 발생할 수 있다.**

싱글톤 객체에서의 동시성 문제를 쓰레드 로컬로 해결할 수 있다.

> **참고** <br/>
> 이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드 마다 각각 다른 메모리 영역이 할당된다. <br/>
> 동시성 문제가 발생하는 곳은 주로 인스턴스 필드 또는 static 같은 공용 필드에 접근할 때 발생한다. <br/>
> 동시성 문제는 값을 읽기만 하는 상황에는 발생하지 않는다. 값을 변경하기 때문에 발생한다.

## 사용법

```java
public class ThreadLocalService {
    private ThreadLocal<String> nameStore = new ThreadLocal<>();

    public String logic(String name) {...}
}
```
- 동시성 문제가 발생하는 필드의 타입을 `String` -> `ThreadLocal<String>` 로 변경해준다.
- 값 저장: `nameStore.set(...)`
- 값 조회: `nameStore.get()`
- 값 제거: `nameStore.remove()`

## 주의 사항

쓰레드 로컬을 모두 사용하고 나면 ***반드시 `ThreadLocal.remove()` 를 호출해서 쓰레드 로컬에 저장된 값을 제거해줘야한다.***

WAS(톰캣) 처럼 **쓰레드 풀**을 사용하는 경우 쓰레드는 한번 사용된 뒤 초기화되지 않고 그대로 쓰레드 풀에 다시 반납된다. (쓰레드 생성 비용이 굉장히 비싸다.) 따라서 **쓰레드 로컬의 값을 제거해주지 않으면 해당 쓰레드가 다시 사용될 때 저장되어 있던 쓰레드 로컬 값이 재사용되는 문제가 발생한다.**

### 예시

#### 사용자 A 데이터 저장

![쓰레드로컬1](../img/../../img/쓰레드로컬(1).png)

- 사용자 A가 저장 HTTP를 요청한다.
- WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
- `thread-A` 가 할당된다.
- `thread-A` 는 사용자 A의 데이터를 쓰레드 로컬에 저장한다.
- 쓰레드 로컬의 `thread-A` 전용 보관소에 사용자 A의 데이터가 저장된다.

#### 사용자 A 쓰레드 반납(쓰레드 로컬의 값 제거X)

![쓰레드로컬2](../img/../../img/쓰레드로컬(2).png)

- 사용자 A의 HTTP 응답이 끝난다.
- WAS는 사용이 끝난 `thread-A` 를 쓰레드 풀에 반환한다.
- 쓰레드를 생성하는 비용은 굉장히 비싸기 때문에 쓰레드를 제거하지 않고 쓰레드 풀을 통해서 쓰레드를 재사용한다.
- `thread-A` 는 쓰레드 풀에 아직 살아있다. 따라서 **`thread-A` 전용 보관소에 사용자 A의 데이터도 함께 살아있다.**

#### 사용자 B 데이터 조회

![쓰레드로컬3](../img/../../img/쓰레드로컬(3).png)

- 사용자 B가 조회 HTTP를 요청한다.
- WAS는 쓰레드 풀에서 `thread-A` 를 반환한다.
- 쓰레드 로컬의 `thread-A` 전용 보관소에서 사용자 A의 데이터가 반환된다.
- **사용자 B는 사용자 A의 정보를 알게된다. (치명적인 문제)**

***결과적으로 쓰레드 로컬의 값을 제거해주지 않으면 다른 사용자의 정보를 조회하게되는 심각한 문제가 발생하게 된다.***



