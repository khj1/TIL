# React.js
- 리액트는 Front-end용 자바 스크립트 라이브러리다.
- 모듈 방식으로 개발할 수도 있고 jQuery나 다른 라이브러리처럼 페이지 단위 방식으로도 개발할 수 있다.

## 렌더링
```java
ReactDOM.render(리엑트 엘리먼트, 렌더링할 DOM의 위치);
```
- 실제 DOM 노드 즉, ```<div>```, ```<h2>```, ```<span>```와 같은 태그를 만들지 않고, 대신에 DOM 노드를 서술하는 자바스크립트 객체를 만든다.
- ```createElemente()``` 함수에서 반환된 자바스크립트 객체가 실제 DOM 노드로 랜더링되는데, 그것은 ```ReactDOM.render(리엑트 엘리먼트 혹은 JSX, 렌더링할 DOM의 위치);``` 메소드와 동일하다.
- render의 첫번째 인자는 대문자로 명시하면 리액트 컴포넌트를 의미하고, 소문자로 명시하면 HTML 태그를 의미한다.
- 리액트는 실제 DOM을 다루는게 아니라 DOM에 매핑되는 자바스크립트 객체를 다룬다는 것이 Virtual DOM(가상돔)의 핵심 개념이다.
- 만일 특정한 속성을 수정하게 되면 자바스크립트 객체에서 바뀐 부분을 찾는다. DOM에서 찾는게 아니라 메모리에 올라간 자바스크립트 객체에서 바뀐 부분을 비교 검색하기 때문에 실제 DOM을 다루는 것 보다 훨씬 빠르게 업데이트가 가능해진다.
- 처음에 한번 전체 DOM을 렌더링한 이후에는 필요한 부분만 업데이트를 하게된다.
- 메모리에 올라간 자바스크립트 객체에서 변경된 부분을 찾은 후 매핑되는 DOM만 업데이트하는 방식이다.

## DOM과 Virtual DOM
- DOM이란 (Document Object Model)의 약자로 객체를 통해 구조화된 문서를 표현하는 방법이다.
- DOM은 트리형태로 되어 있어서 특정 node를 찾을 수도 있고 수정하거나 제거 할 수 있다.
- DOM은 동적인 UI에 최적화가 되어 있지 않기 때문에 JQuery등의 라이브러리를 사용하여 동적인 효과를 줄 수 있다.
- 하지만 큰 규모의 웹 어플리케이션(트위터,페이스북등) 에서는 스크롤을 내리다 보면 정말 수많은 데이터가 로딩이 되고 각 데이터를 표현하는 요소도 많아지게 된다. 
- 이와같은 DOM 요소의 갯수가 몇 백개 몇 천개 단위로 많아진 상태에서 DOM에 직접 접근하여 변화를 주다보면 성능상 이슈가 발생하게 된다.
- 이는 DOM자체가 Javascript엔진에 비해 느려서 그런 것이 아니라, 브라우저 단에서 DOM의 변화가 일어나면, CSS를 다시 연산하고 레이아웃을 구성하고 웹 페이지를 Repaint 하는데서 시간이 허비되기 때문에 느려진다고 할 수 있다.
- 레이아웃 구성을 Reflow라고 하고, 색상변경 같은 레이아웃에 관계 없는 것들은 Repaint라고 한다
- 즉 웹브라우저 등의 클라이언트 측의 로직 때문에 어플리케이션의 속도가 느려진다고 볼 수 있다.
- 이러한 HTML마크업을 시각적인 형태로 변환하는 시간이 드는 것은 어쩔 수 없다. 따라서 최소한의 DOM 조작을 통해 작업을 처리하는 방식으로 이를 개선 할 수 있다.
- 그중에 DOM작업을 가상화 하여 미리 처리한 다음 한꺼번에 적용할 수 있는 방법이 있다.

## Virtual DOM이란?
- Virtual DOM을 이용하면 실제 DOM에 접근하여 조작하는 대신에, 이를 추상화시킨 자바스크립트 객체를 구성하여 사용한다. (실제 DOM의 가벼운 복사본이다)
- 가상 DOM은 실제DOM의 상태를 메모리 위에 계속 올려두고 DOM에 변경이 있을 때만 해당 내용만 반영한다.	
- 그래서 성능 향상을 가져오게 하는 개념이다.

## JSX (Javascript XML)
- createElement()에 의해 반환되는 리액트 엘리먼트(자바스크립트 객체)를 쉽게 만들기 위한 자바스크립트 확장 문법이다
- 다음의 두 예제는 완전히 동일하다.
    ```java
    // 1
    const element = (
        <h1 className="greeting">
            Hello, React!
        </h1>
    );

    // 2
    var element = React.createElement("h1", {
        className : "greeting"
    }, "Hello, React!");
    ```
- JSX 태그는 HTML 태그 뿐만 아니라 사용자 정의의 임의 태그로도 구성이 될 수 있다
- JSX내에 자바스크립트 코드를 작성할때는 JSX Expression인 ```{자바스크립트코드}```를 사용하여 작성한다
- JSX의 속성은 속성값이 자바스크립트 변수일때는 ```속성명={자바스크립트변수}``` 식이나 일반 값일때는 ```속성명="속성값"```으로 한다
- JSX를 if 와 for루프 안에서 사용할 수 있고, 변수에 할당하고, 인수로 받아 들여 함수에서 반환 할 수 있다. 
- JSX는 HTML보다 자바 스크립트에 가깝기 때문에 ReactDOM은 camelCase 형태의 HTML 속성 이름을 사용한다.
- 예를 들어 class대신 className 그리고 onclick대신 onClick를 속성명으로 사용한다.
- JSX에 HTML태그 처럼 style속성을 적용하려면 style="color:red"방식대로 하면 에러가 발생한다.
- JSX내에서 위처럼 스타일을 주려면 style={{camelCase형태의 css속성명:변수 혹은 스트링}}
- 이때 바깥쪽 {}는 JSX에서 JavaScript를 사용하기 위함이고 안쪽 {}는 JavaScript객체(JSON)이다
- JSX태그에는 자식을 포함 할 수 있는데 없는 경우는 Self closing />을 통해 닫고, 자식이 있는 경우에는 반드시 최상위 태그 하나로 감싸야 한다

## 컴포넌트
- 재사용이 가능한 UI 모음이다
- 함수형 component 와 클래스형 component 두가지가 있다
- 함수형 component는 상태를 유지 할 수 없다. 그래서 변화하는 데이타를 가지려면, 클래스형 component로 만들어야 한다
- 그래서 함수형 컴포넌트를 stateless 하다 하고, 클래스형 컴포넌트를 stateful 하다고 한다
- 함수형 컴포넌트는 props를 입력으로 받아서 JSX(React Element)를 출력(리턴)하는 기능을 수행한다. 
- 클래스형 컴포넌트는 ```state```를 가질수 있고, 반드시 ```render()```함수를 가져야 한다. 따라서 변화하는 데이타가 있는 컴포넌트는 클래스 컴포넌트로 만든다.
- 함수형 컴포넌트는 함수 호출이고 클래스형 컴포넌트는 생성자 함수 호출이다.
- 함수형 컴포넌트는 메모리를 적게 사용한다 그리고 생명주기가 없다. 하지만 클래스형 컴포넌트는 생명주기를 가지고 있다. 

### 함수형 컴포넌트
- 자바스크립트 함수로 컴포넌트를 만든다.
- 함수형 컴포넌트를 만들 때 첫글자는 대문자로 만든다.
- ```props```를 입력으로 받아서 JSX(React Element)를 리턴하는 함수다. **props는 읽기 전용**이다.
- 함수 선언 방식
  - 일반적인 함수
  - 익명 함수
  - 화살표 함수

### 클래스형 컴포넌트
- React의 ```Component```를 상속받고 ```render()``` 함수를 반드시 오버라이딩해야 한다.
- ```render()``` 함수는 React 엘리먼트를 반환한다.
- ```class```로 만든 컴포넌트는 생명 주기를 가지고있다.
- 상태관리가 필요한 컴포넌트는 ```class```로 컴포넌트를 만든다. 즉 ```state```를 가질 수 있다.
- 내부적으로 ```props``` 객체를 포함하고 있다. 함수형 컴포넌트에서는 함수의 인자로 ```props```를 전달받지만, 클래스형 컴포넌트에서는 ```this.props```로 접근한다.

## props, state
### props
- 읽기 전용이다. 따라서 최상단 엘리먼트가 모든 ```props```를 가진다.
- 태그의 속성 형태로 부모에서 자식에게 내려보내는 데이터를 의미한다.
- ```props```를 받은 자식에서는 ```props```값을 변경할 수 없다.
- ```props``` 값을 자식에서 변경하기 위해서는 이벤트를 통해 부모에게 요청해야한다.
- 자식에서 ```props```를 변경하면 부모는 그 변경된 값을 알 수가 없다. 즉, 상태 관리가 불가능해지므로 ```prop```는 읽기전용 속성이다.\

### state
- ```state```는 가변 데이터로 **클래스 컴포넌트에서만 사용할 수 있다.**
- ```setState()``` 함수로 ```state```를 수정해야 ```render()``` 함수가 호출되어 상태가 변환된다.
- 특정 자식 컴포넌트에서만 관리되는 ```state```는 **local state**이다.
- 다른 컴포넌트와 공유되어야하는 컴포넌트는 Top 레벨 컴포넌트에 ```state```를 두고 공유해야 한다. 이와같은 컴포넌트를 **application state**라고 한다.