# 스프링의 역사

## EJB (Enterprise Java Beans)

스프링 이전엔 **EJB**가 주류였다. EJB가 제공하는 기능은 다양했고 ORM을 지원하는 EJB 엔티티빈 기능도 있었다. 그렇다면 EJB는 사양됐을까?

- 너무 비싸고 무거웠다.
- 모든 코드를 EJB 인터페이스에 의존적으로 설계해야 했다.
- 제공하는 기능은 다양했으나 기술의 깊이가 너무 얕았다.

> EJB로 인해 **POJO**(Plain Old Java Object) 방식이 확산됐다.

## 스프링의 등장

- 2002년 개발자 로드 존슨이 책을 출간하면서 시작됨
- EJB의 문제점을 지적함. 
  - EJB( Enterprises JavaBeans ) 없이도 고품질의 확장 가능한 어플리케이션을 개발할 수 있음을 보여줬다.
- 책 출간 이후 유겐 휠러와 얀 카로프가 로드 존슨에게 오픈소스 프로젝트를 제안
- 스프링의 핵심 코드의 상당수는 유겐 휠러가 지금도 개발하고 있다.
- 스프링 이름은 전통적인 J2EE( EJB )라는 겨울을 넘어 새로운 시작이라는 뜻으로 짓게됐다.

## 스프링

***스프링*** 이라는 단어 자체는 문맥에 따라 다르게 사용된다.

- 스프링 DI 컨테이너 기술
- 스프링 프레임 워크
- 스프링 부트, 스프링 프레임워크를 모두 포함한 스프링 생태계

## 스프링 부트

- 스프링을 **편리하게** 사용할 수 있도록 지원해준다.
- 단독으로 실행할 수 있는 스프링 애플리케이션을 **쉽게 생성**할 수 있다.
- **Tomcat**같은 **웹 서버를 내장**해서 별도의 서버를 설치하지 않아도 된다.
- **손쉬운 빌드 구성**을 위한 starter 종속성을 제공한다.
- 스프링과 외부 **라이브러리를 자동으로 구성**해준다.(버전 호환성 자동 체크)
- 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능을 제공한다(**모니터링**)
- 관례에 의한 간결한 설정(설정 메뉴얼 제공)

## 핵심 개념

### 이 기술은 왜 만들어졌는가?

- 스프링은 자바 언어 기반의 프레임 워크
- 자바 언어의 가장 큰 특징: ***객체 지향 언어***
- 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내는 프레임워크
- 스프링은 ***좋은 객체 지향*** 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 좋은 객체 지향이란?

### 객체 지향의 특징

- 추상화
- 캡슐화
- 상속
- 다형성

### 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그래밍을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 **객체**들의 **모임**으로 파악하고자 하는 것이다. 
  - 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.(협력)
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
  
### 유연하고, 변경이 용이?

- 레고 블럭 조립하듯이
- 키보드, 마우스를 갈아 끼우듯이
- 컴퓨터 부품을 교체하듯이
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
- 
### 다형성의 실세계 비유
- 실세계와 객체 지향을 1:1로 매칭할 순 없다.
- 역할과 구현으로 세상을 구분한다고 가정.
- 새로운 모델의 키보드로 교체한다고 해도 사용자가 바뀌어야한다거나 컴퓨터의 USB 단자를 바꿀 필요가 없음
- 뮤지컬의 특정 배역에 수많은 배우들이 참여할 수 있다.( 고유한 누군가만 가능한 것이 아님 )

### 실세계에서의 역할과 구현을 분리

- **역할**과 **구현**으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.(대본, USB 단자)
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 자동차의 내부 구조를 몰라도 엑셀, 브레이크등의 인터페이스만 알면 운전할 수 있다.
- 클라이언트는 구현 대상의 내부구조가 변경되어도 영향을 받지 않는다.(USB 업그레이드)
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.(새로운 USB 모델 구매)

### 프로그래밍에서의 역할과 구현의 분리

- 객체를 설계할 때 역할과 구현을 명확히 분리해야 한다.
- 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 생성
- 확장 가능한 설계가 가능해진다.
  - 새로운 기능이 필요해져서 이를 구현한 새로운 객체를 만들어도 클라이언트가 변할 필요 없이 새로운 객체로 변경해주기만 하면 된다.
  - 예를들어 특정 인터페이스를 구현하도록 하고 메소드를 오버라이딩하게 해준다면 내부적인 설계를 크게 바꾸지 않아도 새롭게 개발한 기능(객체)을 사용할 수 있다.
- 따라서 인터페이스를 안정적으로 설계하는것이 가장 중요하다.
  - 인터페이스 자체가 변경되면 서버 자체적으로 큰 변화가 발생한다.(**OCP**)

### 다형성의 본질

- 인터페이스를 구현한 객체의 인스턴스를 **실행 시점**에 **유연**하게 **변경**할 수 있다.
  - 부모 타입으로 선언된 변수를 참조하는 객체의 오버라이딩된 메서드가 실행됨
- 다형성의 본질을 이해하려면 **협력**이라는 객체 사이의 관계에서 시작해야한다.
- ***클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.***

### 스프링과 객체 지향

- **다형성**이 가장 중요하다
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 **제어의 역전**(IoC), **의존 관계 주입**(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯 구현을 편리하게 변경할 수 있다.

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- **SRP**: 단일 책임 원칙(Single Responsibility Principle)
- **OCP**: 개방-폐쇄 원칙(Open/Closed Principle)
- **LSP**: 리스코프 치환 원칙(Liskov Substitution Principle)
- **ISP**: 인터페이스 분리 원칙(Interface Segregation Principle)
- **DIP**: 의존 관계 역전 원칙(Dependency Inversion Principle)

### SRP: 단일 책임 원칙( Single Responsibility Principle )

- **하나의 클래스**는 **하나의 책임**만 가져야 한다.
- 하지만 하나의 책임이라는 것은 모호하다.
  - 책임이 클 수도, 작을 수도 있다.
  - 책임이 문맥과 상황에 따라 다를 수 있다.
- ***중요한 기준은 변경이다.*** 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것.
  - UI 변경
  - 객체의 생성과 사용을 분리

### OCP: 개방-폐쇄 원칙( Open/Closed Principle )

- 소프트웨어 요소는 ***확장에는 열려***있으나 ***변경에는 닫혀***있어야 한다.
- 확장하려면 당연히 기존 코드를 변경해야하는 것이 아닌가?
- ***다형성***을 활용하면 된다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현.

#### OCP의 문제점

- 구현 객체를 변경하려면 클라이언트 코드를 변경해야한다.
  - ```MemberRepository m = new MemoryMemberRepository(); ``` : 기존 코드
  - ```MemberRepository m = new JdbcMemberRepository(); ``` : 변경 코드
- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.( 기존 코드가 변경됨 )
- 이 문제를 어떻게 해결할 것인가?
- 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립, 설정자가 필요하다.
  - DI, 스프링 컨테이너, IoC

### LSP: 리스코프 치환 원칙( Liskov Substitution Principle )

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
  - 인터페이스가 설계될 때 만들어진 **규약을 지켜야 한다는 뜻**이다.
  - 예를 들어 엑셀을 밟으면 차는 가속해야한다. 하지만 차를 만들 때 임의로 엑셀을 밟으면 후진하도록 설계해선 안된다.
- ***다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야한다는 것.*** 다형성을 지워하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

### ISP: 인터페이스 분리 원칙( Interface Segregation Principle )

- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- 인터페이스가 명확해지고 대체 가능성이 높아진다.

### DIP: 의존 관계 역전 원칙( Dependency Inversion Principle )

- 프로그래머는 ***"추상화에 의존해야지, 구체화에 의존하면 안된다."*** 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.
  - ***의존한다는 것***은 내가 해당 코드에 대해 ***안다***는 것을 의미한다.
  - 예를 들어 다음과 같은 코드가 있다고 할 떄
    ```java
    public class MemberService{
        private MemberRepository m = new MemoryMemberRepository(); // 변경 코드
        private MemberRepository m = new JdbcMemberRepository(); // 기존 코드
    }
    ```
    - `MemberService`클라이언트는 `MemberRepository` 인터페이스와 `MemoryMemberRepository` 구현 클래스에 대해서도 알고 있다.( 의존하고 있다. )
    - 따라서 `JdbcMemberRepository`를 새롭게 `MemberRepository`에 할당 해주기 위해서는 기존 코드를 변경해야 한다.(`JdbcMemberRepository`에 대해서도 알고있어야 한다.) 
    - `MemberService`가 구현 클래스를 직접 선택해야하는 문제가 발생(DIP 위반)
- 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.

### SOLID 결론

- 객체 지향의 핵심은 **다형성**이다.
- 다형성 만으로는 부품을 갈아끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 이를 보완할 뭔가가 필요하다.

## 객체 지향 설계와 스프링

### 스프링 이야기에 왜 객체 지향 이야기가 나오는가?

- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하도록 만들어준다.
  - DI( Dependency Injection ): 의존 주입
  - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능을 확장할 수 있음.
  
### 철저히 OCP, DIP를 지키는 것이 장점만 있을까?

- 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  - 개발자가 코드를 한번 더 열어봐야한다.
  - 코드가 인터페이스만으로 추상화되있기 때문에 의존 관계를 살펴보기 위해 설정들을 들여다 봐야한다.
  - 따라서 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고 향후 꼭 필요할 때 리펙터링해서 인터페이스를 도입하는 것도 방법이다.

## 부록

### 참고 서적

- 객체 지향의 사실과 오해
- 토비의 스프링
- 자바 ORM 표준 JPA 프로그래밍

### 인스턴스란?

- **객체 지향 프로그래밍**(OOP)에서 **인스턴스**(instance)는 해당 클래스의 구조로 컴퓨터 저장 공간에서 할당된 **실체**를 의미한다. 
- 여기서 클래스는 속성과 행위로 구성된 일종의 설계도이다. OOP에서 **객체는 클래스와 인스턴스를 포함한 개념**이다.
