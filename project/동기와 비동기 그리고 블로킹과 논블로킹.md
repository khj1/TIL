# 동기/비동기 그리고 블로킹과 논블로킹

동기/비동기 그리고 블로킹과 논블로킹는 서로 어떻게 다른 것일까?

- 동기/비동기는 결과 값이 반환되는 시간에 대한 것이다.
- 블로킹/논블로킹은 제어권이 반환되는 시점에 대한 것이다.

## 동기/비동기

- **동기(Synchronous)** 는 요청한 작업에 대해 완료 여부를 따져 순서대로 처리하는 것을 말한다. 실행 순서가 보장되기 때문에 상대적으로 안전하지만 느리다.
- **비동기(Asynchronous)** 는 이전 작업의 완료 여부를 따지지 않고 요청이 들어올 때마다 작업을 수행한다. 비동기로 처리한다는 의미는 백그라운드에서 작업을 실행한다는 의미다.
  - 비동기의 핵심은 결과물이 즉시 주어지지 않고 응답이 올 때 까지 다른 작업을 수행할 수 있는 것이다.
  
![](../img/Synchronous%20vs%20Asynchronous.png)

정리하자면 동기와 비동기의 차이는 작업 순서를 어떻게 처리하느냐에 있다. 동기는 요청한 순서대로 작업이 처리됨을 보장하는 반면 **비동기는 요청한 순서와 무관하게 작업 처리 순서가 지켜지지 않을 수 있다.**


## Blocking/Non-Blocking

- **Blocking** 은 다른 요청을 처리하기 위해 현재 작업을 차단/대기 시킬 수 있음을 의미한다. 요청 이후에 제어권이 넘어간다.
- **Non-Blocking** 은 다른 요청을 처리하기 위해 현재 작업을 막지 않는다는 의미다. 요청 이후에 제어권을 즉시 돌려받는다.
  - 논블로킹은 결과가 나올때까지 기다리지 않고 즉시 반환받는다는 의미도 있다. 
  - 동기/논블로킹 시 작업이 아직 끝나지 않았다면 작업 진행중이란 의미로 **EWOULDBLOCK**를 반환한다.

![](../img/BlockingVSNonBlocking(2).png)

비동기는 병렬에 가깝고, 논블로킹은 폴링에 가깝다.

> 폴링이란 어떤 시스템 콜이 성공적으로 실행될 때까지 계속 루프를 돌면서 확인하는 것을 의미한다.

이처럼 비동기와 Non-Blocking은 유사해보이지만 개념적으론 엄연히 다른 의미다. 일반적으론 동기/Blocking, 비동기/Non-blocking이 세트로 묶여 사용되는 경우가 많지만 동기/Non-Blocking과 같은 경우도 충분히 가능하다.

### 동기, Non-Blocking 예시

예를 들어 이전 요청이 완료되고 나서야 다음 작업을 수행할 수 있을때, 그리고 작업 중에 다른 요청이 들어와도 현재 작업을 멈추지 않는 경우가 동기, Non-Blocking 상황이다.

![](../img/Sync%20Non-Blocking.png)

위 예시에서 팀장, 사원1, 사원2 는 서로 다른 작업을 하고 있다. 팀장이 사원1에게 업무를 지시(새로운 요청)했음에도 팀장은 자신의 업무(현재 작업)을 멈추지 않고 계속 하고 있다. 이것이 Non-Blocking이다.

또한 팀장은 사원1로 부터 결과물(응답)을 받아야 사원2에게 새로운 요청을 할 수 있다. 이것이 동기적인 상황이다.

## 병렬성 vs 동시성

지금까지 자료를 참고하고 공부하면서 이해한 바로는, **병렬처리**란 여러가지 작업을 동시에 처리하는 것이다. 핵심은 **실제로 동시에 처리한다는 것이다.**

**동시성**의 핵심은 **동시에 처리하는 것처럼 보이게 만든다는 것**이다. 이는 CPU가 작업마다 시간을 분할해 적절하게 **context switching**을 하기 때문에 가능하다.

> **context switching**은 쓰레드 뿐만 아니라 프로세스 단위에서도 발생한다.

병렬성은 멀티 코어, 멀티 쓰레드가 필수적이라면 동시성은 단일 코어, 단일 쓰레드에서도 충분히 가능하다.

정리하자면
- 동시성은 논리적 개념, 싱글 코어, 멀티 코어에서 모두 동작한다.
  - n개로 줄을 서 손님을 응대하는 1명의 직원
  - 여러가지 일을 동시에 처리하는 것처럼 보이게 만든다.
- 병렬성은 물리적 개념, 멀티 코어에서만 동작한다.
  - n개로 줄을 선 손님을 응대하는 n명의 직원
  - 여러가지 일을 실제로 동시에 처리한다.

동시성은 하드웨어적인 한계를 극복하기 위해 등장했다. 병렬성은 코어 숫자에 의존적이다. 코어가 많으면 많을수록 병렬 프로그래밍의 효율이 증가하지만, 하나의 CPU에 많은 코어를 구현하기가 쉽지 않다.

## 궁금증

### 비동기, 논블로킹 작업 시 컨텍스트 스위칭이 발생하지 않는건가?

결과부터 말하면 그건 알 수 없다. 컨텍스트 스위치의 여부는 시스템 상태나 내부 구현 방법에 따라 달라질 수 있다. 같은 비동기, 논블로킹 환경이라 하더라도 단일 쓰레드로 구현이 되었다면 컨텍스트 스위치가 발생하지 않고, 멀티 쓰레드로 구현이 되었다면 컨텍스트 스위치가 발생한다.