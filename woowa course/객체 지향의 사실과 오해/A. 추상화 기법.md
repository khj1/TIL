# 부록 A - 추상화 기법

## 분류의 인스턴스화

```
- 자동차
    - 자동차 A
    - 자동차 B
    - 자동차 C
```

### 개념과 범주

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.

예를 들어 세상에 존재하는 무수히 많은 자동차와 나무를 개별적으로 다루지 않고 자동차나 나무라는 범주로 묶음으로써 세상에 존재하는 복잡성을 낮출 수 있다.

이때 무수히 많이 존재하는 개별적 존재를 **객체**, 하나의 범주, 개념을 **타입**이라고 한다. 객체는 곧 타입의 **인스턴스**를 의미한다.

## 일반화와 특수화

```
- 운송수단
    - 자전거
    - 자동차
    - 기차

- 포유류
    - 육식 동물
        - 고양이
        - 개
    - 초식 동물
```

### 서브 타입

어떤 타입이 다른 타입보다 일반적이라면 **슈퍼타입**, 다른 타입보다 특수하다면 **서브타입**이라고 한다.

- 슈퍼타입의 정의가 100% 서브타입에 정의되어야 한다.
- 서브타입은 슈퍼타입이다. 라는 구문이 참이어야 한다.

### 상속

상속은 **서브 타이핑**과 **서브 클래싱**으로 나뉜다.

서브 클래스가 슈퍼 클래스를 대체할 수 있다면 서브 타이핑, 그렇지 않다면 서브 클래싱이라고 한다. 흔히 서브 타이핑을 인터페이스 상속, 서브 클래싱을 구현 상속이라고 한다.

어떤 클래스가 다른 클래스를 상속받았다는 사실만으로는 두 클래스 간의 관계가 서브 타이핑인지, 서브 클래싱인지 확인할 수 없다.

일반화를 위한 서브 타이핑은 서브 타입과 슈퍼 타입의 구조적, 행위적 순응 관계를 의미하며 대체 가능성을 내포한다. 반면 서브 클래스가 슈퍼 클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브 타이핑이 아니라 서브 클래싱이라고 한다.

## 집합과 분해

### 계층적인 복잡성

시계 제작자가 있다. 시계를 만들기 위해선 1,000개 정도 되는 부품들을 하나하나 조립해야한다. 만약 시계를 조립하다가 전화가 걸려오면 조립하던 부품들이 떨어져 나가게되고 시계 제작자는 처음 부터 다시 조립을 시작해야한다.

만약 1,000여개의 부품들을 조금씩 모아 파츠를 구성하는 것은 어떨까? 100개의 부품을 모아 하나의 파츠를 만들고 그 파츠를 2개씩 묶어서 다시 하나의 파츠를 구성한다면 중간에 조립을 멈추더라도 다시 조립을 시작하기 훨씬 수월해질 것이다.

이 예시를 통해 두 가지 교훈을 얻을 수 있다.

- 복잡성은 계층의 형태를 띈다.
- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그사이에 존재하는 안정적인 형태의 수와 분포에 의존한다.

안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라고 한다. 이와 반대로 전체를 부분으로 분할하는 행위를 **분해**라고 한다.

집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다. 외부에서는 전체에 관해서만 알고 있고 내부의 세부 사항에 대해서는 알지 못하기 때문에 내부의 구성을 변경하더라도 외부에 영향을 미치지 않는다.

### 합성 관계

상품 주문을 생각해보자. 여러 상품을 한 번에 주문할 수 있다. 우리는 주문 내역을 통해 방금 주문한 상품들의 정보를 확인할 수 있다. 각 주문 내역은 주문과 독립적으로 존재할 수 없다. 주문 내역은 반드시 어떤 한 주문의 일부로 생성되기 때문에 주문의 일부여야 한다. 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 **합성 관계**를 사용한다.

상품과 주문 내역 사이에도 관계가 존재하지만 상품은 주문 내역의 일부가 아니다. 따라서 주문과 주문 내역 사이의 관계는 전체와 부분 간의 관계를 나타내는 합성 관계인데 비해 주문 내역과 상품 간에는 단순한 물리적 통로가 존재할 뿐이다. 이를 **연관 관계**라고 한다.

합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다. 주문 객체가 제거되면 자동으로 주문 내역 객체도 제거된다.

반면 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다.

### 패키지

합성 관계를 통해 커다란 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 많아질수록 얽히고 설킨 클래스 간의 의존성을 관리하는 일은 악몽으로 변해간다. 복잡한 클래스의 미로 속에서 길을 잃고 헤메지 않으려면 구조에 관한 큰 그림을 안내해줄 지도가 필요하다.

소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지 또는 모듈이라고 한다.
