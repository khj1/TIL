# Replication
한 서버에서 다른 서버로 데이터를 동기화하는 작업을 의미한다.
- **소스 서버**: 원본 데이터를 가지고 있다. (Master)
- **레플리카 서버**: 복제된 데이터를 가지고 있다. (Slave)

## Replication을 왜 사용할까?
가장 큰 목적은 데이터 베이스의 부하를 줄이기 위함이다. 하지만 트래픽이 크지 않은 서비스에서도 Replication을 적용하는 곳이 많다. 다른 이점은 어떤 것들이 있을까?

### 스케일 아웃
- 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조

### 데이터 백업
- 레플리카를 하지 않더라도 데이터 백업은 반드시 해야한다.
- 백업 과정은 실행중인 쿼리들에 영향을 줄 수 있다.
- 레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업 시 발생하는 문제들을 해결할 수 있다.

> 하지만 레플리카 서버를 두는 것 자체가 안전한 백업이라고 볼 수는 없다. 개발자의 실수로 소스 서버에서 모든 데이터를 지워버렸다면 해당 변경사항이 실시간으로 레플리카 서버에도 반영된다. 따라서 실시간 백업은 레플리카 서버에서 진행하되, 스케쥴러를 활용하여 시간차를 둔 백업을 병행하는 것이 바람직하다.

### 데이터 분석
- 분석용 쿼리는 대량의 데이터를 조회하고 쿼리 자체가 무거운 경우가 많다.
- 분석용 쿼리는 전용 레플리카 서버에서 진행하는 것이 좋다.

### 데이터의 지리적 분산
- 데이터베이스와 애플리케이션 서버가 멀리 떨어져있다면 응답 속도가 느려질 수 밖에 없다.
- 빠른 응답을 위해서 애플리케이션 서버의 지리적 위치에 가깝게 레플리카 서버를 구성하는 것이 좋다.

## Replication은 어떤 방식으로 동작할까? (MySQL 기준)
### 바이너리 로그
MySQL 서버에서 발생하는 모든 변경사항들을 별도의 로그 파일에 순서대로 저장한다.
- 데이터의 변경 내역
- 데이터베이스나 테이블 구조의 변경
- 계정이나 권한의 변경 정보

#### 바이너리 로그를 직접 확인하는 법
```
//바이너리 로그 목록 파일을 볼 수 있다.
show binary logs;

//바이너리 로그 파일명과 위치를 알 수 있다.
show master status; 
```

### 바이너리 로그를 활용하는 방식
1. 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송된다.
2. 레플리카 서버에서는 해당 내용을 로컬 디스크에 적용한다.
3. 자신이 가진 데이터에 반영한다.
4. 소스서버와 레플리카 서버의 데이터 동기화가 이루어진다.

### 데이터 동기화 작업은 세개의 스레드를 통해 이루어진다.
#### Binary Log Dump Thread (소스 서버)
- 바이너리 로그를 레플리카 서버로 전송하는 역할
- 레플리카 서버가 소스 서버에 연결되면 소스 서버에서 내부적으로 Binary Log Dump Thread를 생성한다.

#### Replication I/O Thread (레플리카 서버)
- Binary Log Dump Thread가 보낸 Binary  Log Event를 가져와 로컬 서버의 파일(Relay Log)로 저장하는 역할
- 복제가 시작하면 스레드가 생성되고 복제가 멈추면 스레드가 종료된다.
- 소스 서버에 연결할 때 사용하는 정보는 Connection Metadata에 저장되어있다.
- mysql.slave_master_info 테이블에 저장되어 있다.

#### Replication SQL Thread (레플리카 서버)
- Replication I/O Thread의 Relay 파일에 저장된 이벤트들을 읽고 실행하는 역할이다.
- 이벤트가 저장된 릴레이로그 파일명과 그 위치를 Applier Metadata 파일에 저장하고 있다.
- Applier는 릴레이 파일에 저장된 이벤트들을 서버에 적용하는 컴포넌트를 뜻한다.
- 컴포넌트 어플라이어는 mysql_slave_relay_log_info 테이블에 저장된다.

## 바이너리 로그는 이벤트를 어떻게 식별할까?
- 바이너리 로그 파일 위치 기반
- 글로벌 트랜잭션 ID 기반(GTID)

기본적으로 MySQL 복제를 사용하려면 소스 서버에 반드시 바이너리 로그가 활성돼 있어야 한다.

바이너리 로그가 기록되는 지는 `show master status;`를 통해 확인할 수 있다.

### 바이너리 로그 파일 위치 기반 복제
레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내 위치로 바이너리 로그 이벤트를 식별해서 복제한다.

![image](https://github.com/khj1/TIL/assets/74335027/9374a50c-3f34-4a7d-82d2-593396a11140)

MySQL server-id가 활용된다. 서버 id를 직접 지정해주지 않으면 기본 값 1로 설정된다. 하지만 레플리카 서버에서는 반드시 서버 id를 지정해줘야 한다. 이때 각 레플리카 서버마다 서버 id는 서로 다르게 설정해줘야 한다.

바이너리 로그 파일 기반의 복제는 식별 과정이 소스 서버에서만 유효하다는 단점이 있다.

동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 존재한다는 보장도 없다.

### 글로벌 트랜잭션 아이디(GTID) 기반 복제
복제에 참여한 각 서버들에서 이벤트를 식별하기 위해 만들어진 고유한 이벤트 식별값이다.

## 바이너리 로그는 어떻게 생겼을까? 바이너리 로그를 기록하는 방식
- Statement 방식
- Row 방식
- Mixed 방식

#### 설정 방법
```
set global binlog_format = 'STATEMENT';
```

### STATEMENT
- SQL문을 바이너리 로그에 그대로 기록하는 방식이다.
- 트랜잭션 격리 수준이 반드시 **REPEATABLE-READ 이상**이어야 한다.
- 그 이하 방식에서는 하나의 트랜잭션에서도 각 쿼리가 실행되는 시점마다 스냅샷이 달라질 수 있다.
- 이로 인해 복제시 서버와 레플리카 서버의 데이터가 일치하지 않을 수 있다.
- SQL문을 손쉽게 확인할 수 있다는 장점이 있다.
- **비확정적으로 처리될 수 있는 쿼리**가 실행된 경우 STATEMENT 포맷에서는 복제 시 소스 서버와 레플리카 서버 간 데이터가 달라질 수 있다는 단점이 있다.

> **비확정적으로 처리될 수 있는 쿼리** <br />
> delete나 update 쿼리에 order by 없이 limit를 사용하는 경우를 의미한다. <br />
> 이러면 쿼리를 실행할 때 마다 매번 결과가 달라질 수 있다.

### ROW
- 변경된 데이터 자체를 기록하는 방식이다.
- MySQL 5.7.7 버전부터 바이너리 로그의 기본 포맷이다.
- 어떤 형태의 쿼리든지 복제시 소스 서버와 레플리카 서버의 데이터의 일관성이 보장된다.
- 많은 데이터를 변경할 경우 모든 데이터가 바이너리 로그 파일에 기록되기 때문에 파일의 크기가 단시간에 매우 커질 수 있다.
- 레플리카 서버에서는 어떤 쿼리들이 넘어왔고 현재 어떤 쿼리가 실행중인지 확인할 수 없다.

### MIXED
- STATEMENT와 ROW를 혼합한 방식이다.
- 쿼리의 대부분은 STATEMENT 포맷으로 기록될 가능성이 높다.
- 그런데 실행중인 쿼리가 STATEMENT 포맷으로 기록되어 복제됐을 때 문제가 될 가능성이 있는 안전하지 못한 쿼리라면 ROW 포맷으로 변환되어 기록된다.

## 복제 동기화 방식 (MySQL 기준)
- 비동기 복제
- 반동기 복제

### 비동기 복제
- 소스 서버와 레플리카 서버에 변경 이벤트가 정상적으로 전달됐는지 확인하지 않는다.
- 소스 서버에선 레플리카 서버에 동기화가 잘 이루어졌는지 확인할 수 없다.
- 소스 서버에서 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버까지 전송되지 않을 수 있다.

### 반동기 복제
- 소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트들을 릴레이 로그에 기록 후 응답(ACK)을 보내면 그때 트랜잭션을 완전히 커밋한다.
- 하지만 전송이 보장된거지 실제 적용이 제대로 이루어졌는지를 보장하는 것은 아니다.
- 서버의 응답을 기다려야하기 때문에 트랜잭션 처리가 느려질 수 있다.
- 서버의 응답이 무기한적으로 지연되는 경우 지정된 타임아웃 시간동안 응답이 없으면 비동기 복제 방식으로 전환된다.

## 소스, 레플리카 서버는 어떻게 구성할까?
- **싱글 레플리카 복제**
  - 하나의 소스, 하나의 레플리카
  - 소스 서버에 문제가 생겼을 떄를 대비해 예비 서버 및 데이터 백업 수행을 위한 용도로 사용된다.
- **멀티 레플리카 복제**
  - 하나의 소스, 두개 이상의 레플리카
  - 하나의 레플리카는 예비 용도
  - 나머지 레플리카는 읽기 요청 처리를 분산하기 위한 용도
- **체인 복제**
  - 하나의 소스 서버에 할당된 레플리카 서버가 많아질 수록 바이너리 로그를 읽고 전달하는 작업 자체만으로 부하가 될 수 있다.
  - 소스 서버가 해야할 바이너리 로그 배포 작업을 새로운 분배 서버에 위임하는 방식이다.
  - 이로써 소스 서버는 쓰기 연산에만 집중할 수 있다.
- **듀얼 소스 복제**
    - 두개의 서버가 서로 소스 서버이자 레플리카 서버인 형태이다.
    - 두 서버 모두 쓰기가 가능하다.
    - 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용된다.
    - 싱글 레플리카 방식과 동일해보이지만 하나의 서버에 문제가 생겼을 경우 서버 전환이 빠르다는 장점이 있다.
- **멀티 소스 복제**
  - 하나의 레플리카, 둘 이상의 소스
  - 여러 서버에 분산되어 있는 데이터들을 하나의 서버에 통합하거나
  - 파편화돼있는 테이블 데이터를 하나의 테이블로 통합할 때 사용할 수 있다.