# HTTP 버전에 따른 차이
## HTTP 1.0
### 매 요청마다 커넥션을 수립한다.
- TCP 커넥션이 HTTP 요청마다 3-way Handshake와 TearDown 반복
- 서버에 오버헤드가 발생할 수 있고 시간이 지연된다.

### 커넥션 하나당 요청 하나와 응답 하나만 처리한다.

## HTTP 1.1
### 커넥션 유지
- 한개의 TCP 세션을 통해 여러개의 컨텐츠를 요청할 수 있다.
- Pipelining 클라이언트는 응답에 상관없이 요청을 보내고 서버에서는 응답을 요청이 들어온 순서대로 보낸다.
  - 이로인해 HOL(Head Of Line) Blocking이 발생할 수 있다.
  - 서버는 요청이 들어온 순서대로 응답을 보내야하기 때문에 응답이 지연되면 그 다음 요청에 대한 응답에 blocking이 발생할 수 있다.
- TCP 다중 연결이 가능하다. 많은 양의 objects를 검색하는 성능이 높아졌다.

### 새로운 헤더 추가
- 호스트 헤더(가상 호스팅): 하나의 IP 주소에 여러 도메인을 적용할 수 있다.
- proxy-authentication, proxy-authorization 헤더 추가
  - 프록시가 사용자의 인증을 요구하는 것이 가능해졌다.
- 요청과 응답이 많아지면서 중복되는 header 내용이 많아졌다.
  - 불필요한 데이터를 주고 받아 네트워크 자원 낭비가 발생한다.

## HTTP 2.0
### HTTP 메시지 전송 방식의 변화
- HTTP/1.0은 text 형식으로 메시지를 전달했다.
- HTTP/2는 프레임 단위로 요청, 응답 메시지를 나누고, 바이너리 형식의 인코딩으로 변경했다.
- 이로인해 파싱, 전송 속도가 빨라졌다.

### HOL Blocking 문제를 개선했다.
  - 멀티플렉스 스트림을 사용해 요청과 응답을 다중화 시켰다.
  - 한 커넥션으로 동시에 여러개의 메시지를 주고 받고, 응답은 순서에 상관없이 stream으로 주고 받는다.
  - 응답에 대한 우선 순위를 정해 우선 순위가 높을 수록 응답을 빨리한다.
  
### 헤더 중복 해결
- Header Table과 Huffman Encoding 기법을 이용해 압축한다.
- 클라이언트와 서버는 각각 Header Table을 관리한다.
- 이전 요청과 동일한 필드는 table의 index만 보내고 변경되는 값은 Huffman Encoding 후 전송한다.
- Header의 크기를 줄여 페이지 로드 시간이 감소했다.

> **? Huffman Encoding** <br/>
> 입력 파일의 문자 빈도 수를 가지고 최소 힙을 이용하여 파일을 압축하는 과정이다.

## HTTP 3.0
- 전송 계층에 UDP 기반의 QUIC 프로토콜을 사용한다.
- HTTP 2.0은 애플리케이션 계층(L4)에서의 HOLB는 해결했지만, 전송 계층(L3)에서의 HOLB는 해결하지 못했다.
- 기본적으로 TCP 통신을 하게되면 패킷이 중간에 손실됐을 때 재전송을 해야하기 때문에 HOLB가 발생하게 된다.
- 이러한 문제를 해결하고자 TCP/IP 4계층에 QUIC 프로토콜을 적용시키기 위해 설계된 것이 HTTP 3.0이다.

> **? QUIC** <br />
> - Quick UDP Internet Connection
> - UDP를 사용하여 빠르게 인터넷을 연결하는 새로운 프로토콜이다.
> - QUIC은 TCP + TLS + HTTP의 기능을 모두 구현한 프로토콜이다.
> - TCP 프로토콜의 무결성 보장 알고리즘과 SSL이 이식됨으로써 높은 성능과 신뢰성을 충족시켰다.

### HTTP 3.0 장점
#### 연결 시 레이턴시 감소
기존 TLS + TCP 에서는 TLS 연결을 위한 핸드쉐이크와 TCP 연결을 위한 핸드쉐이크가 각각 발생했다.

그래서 TCP는 연결을 생성하기 위해 기본적으로 1 RTT가 필요하고, 여기에 TLS를 이용한 암호화 통신까지 한다면 3 RTT가 필요하게 된다.

> **? RTT** <br />
> Round Trip Time <br />
> 요청(SYN)을 보낼 때부터 요청에 대한 응답(SYN + ACK)을 받을 때 까지의 왕복 시간을 의미한다.

UDP 위에서 동작하는 QUIC은 통신을 시작할 때 3-way handshake 과정을 거치지 않아도 되기 때문에 첫 연결 설정에 1 RTT만 소요된다. UDP는 연결 설정에 필요한 정보와 실질적인 데이터까지 모두 보내버리기 때문이다.

추가로 QUIC은 TLS 인증서도 내포하고 있기 때문에 최초의 연결 설정에 필요한 인증 정보와 데이터를 함께 전송한다. 따라서 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다.

한번 연결에 성공하기만 하면 서버는 그 설정을 캐싱해놓는다. 다음 연결 때는 캐시를 불러와 바로 연결을 하기 때문에 추가적인 핸드 쉐이크 없이 0 RTT 만으로 바로 통신을 시작할 수 있다는 장점이 있다.

#### 보안이 더욱 강화됐다.
HTTP/3와 그 기반 기술인 QUIC는 TLS 암호화 방식을 기본적으로 사용한다. QUIC 내에는 TLS가 포함되어있기 때문에 TCP와 달리 헤더 영역도 같이 암호화된다.

> **? TLS vs SSL** <br />
> TLS(Transport Layer Security)는 SSL(Secure Sockets  Layer)가 기존에 갖고있던 보안적 결함을 보완하고 최적화시킨 보안 프로토콜이다.

#### 네트워크가 변경되도 연결이 유지된다.

TCP의 경우 클라이언트와 서버가 서로를 구분하기 위해서는 클라이언트 IP, 클라이언트 PORT, 서버 IP, 서버 PORT 이렇게 네 가지가 필요하다. 그래서 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다.

와이파이 존에서 LTE 데이터를 사용하게 됐을 때 동영상 끊김과 같이 일시적인 지연이 일어나는 이유는 이때 클라이언트 IP가 바뀌기 때문이다. 그래서 다시 연결을 생성하기 위해 핸드 쉐이크 과정을 거쳐야한다는 것이고, 그 과정에서 다시 지연시간이 발생하게 된다.

반면 QUIC은 **Connection ID** 를 사용하여 서버와 연결을 생성한다. Connection ID의 각 연결은 연결 식별자나 연결 ID를 가지므로 이를 통해 연결을 식별한다.

Connection ID는 랜덤한 값일 뿐 클라이언트 ID와는 전혀 무관한 데이터이기 때문에 클라이언트 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 따라서 새로 연결을 생성할 때 거쳐야 하는 핸드 쉐이크 과정을 생략할 수 있다.

### HTTP 3.0 단점
#### 기존 쳬계 호환성 문제
HTTP/1.1 이나 HTTP/2 기반의 프론트엔드단 최적화를 적용한 기업의 경우 QUIC 도입으로 인해 오히려 성능이 반감될 수 있다.

#### 암호화로 네트워크 제어가 힘들어진다.
QUIC은 기존에는 암호화하지 않았던 헤더 필드도 암호화 한다. 헤더 정보를 사용하는 ISP나 네트워크 중계회사들은 기존에 암호화하지 않던 헤더 필드 영역들을 읽을 수 없어 네트워크 혼잡을 관리하기 위한 최적화를 하기 힘들어진다. 예를 들어 패킷이 ACK인지 재전송인지 알 수 없게 된다. RTT 추정은 더 여럽다.

#### 암호화로 리소스가 많이 든다.
QUIC는 패킷별로 암호화를 한다. 이는 기존에 TLS-TCP에서 패킷을 묶어서 암호화하는 것보다 더 큰 리소스 소모를 불러올 수 있다.

#### QUIC는 CPU를 너무 많이 사용한다.