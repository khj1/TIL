## 인덱스란?
쉽게 찾아볼 수 있도록 **일정한 순서**에 따라 놓은 목록이다. 원하는 값을 빠르게 찾기 위해 사용한다.

인덱스가 없을 때 DB는 Full scan을 기본으로 한다. 모든 데이터를 순차적으로 확인하기 때문에 검색 속도가 현저하게 느려질 수 밖에 없다.

DB 테이블의 검색 성능을 향상시키는 자료구조이며 **WHERE** 절 등을 통해 활용된다.

## 인덱스의 특징
- 항상 최신의 **정렬 상태**를 유지한다.
- 인덱스도 하나의 데이터베이스 객체다.
- 데이터베이스 크기의 약 10% 정도의 저장 공간이 필요하다.

## 인덱스 알고리즘

> **용어 설명** <br/>
> 페이지: 데이터가 저장되는 단위(16 Kbyte)

### Full Table Scan
테이블의 모든 데이터를 순차적으로 확인한다.
- 접근 비용이 감소한다.
- 적용 가능한 인덱스가 없는 경우 사용한다.
- 인덱스가 적용되어 있어도 인덱스 처리 범위가 너무 넓은 경우 사용한다.
- 크기가 작은 테이블에 접근할 때 사용한다.

### B-Tree
- 트리 높이가 같다.
- 자식 노드를 2개 이상 가질 수 있다.
- 기본적인 데이터 베이스의 인덱스 구조다.
- 루트 페이지, 브랜치 페이지, 리프 페이지로 구성된다.

#### 데이터 삽입 시 페이지의 용량이 가득 찬 상태라면?
- 비어 있는 페이지를 새로 확보한다.
- **페이지의 데이터를 공평하게 나누어 새로운 페이지로 이동시킨다.**(페이지 분할)
- 이러한 이유로 조회를 제외한 나머지 작업의 성능은 인덱스 적용 후 오히려 악화된다.
  
#### 데이터를 제거하는 경우?
- 기존 값을 제거하는 것이 아니라 사용안함 표시를 추가한다.

인덱스를 사용함으로써 WHERE 절로 처리할 대상을 찾기 위한 조회 성능은 향상된다. 하지만 사용하지 않는 인덱스가 적용되었다면 불필요한 처리량이 증가하고, 사용 안함 표시로 인해 페이지가 낭비되는 문제가 발생한다.

> **Binary Search Tree** <br />
> 이진 탐색 트리 (이진 탐색, 연결 리스트) <br />
> 이진 탐색 트리의 경우 사용하는 방식에 따라 시간 복잡도가 달라진다. 이러한 문제를 해결하기 위해 등장한 것이 **B-Tree(Balanced-Tree)** 이다.

## 인덱스 종류
- 클러스터링 인덱스
- 논-클러스터링 인덱스

### 클러스터링 인덱스
- 실제 데이터와 같은 무리의 인덱스를 의미한다.
- 클러스터링 인덱스를 적용하면 Primary Key를 기준으로 데이터를 정렬하고 정렬된 순서에 맞춰 페이지를 생성한다.
- 페이지가 생성되면 페이지(리프 페이지, 데이터 페이지) 가장 상위의 데이터들을 모아 루트 페이지를 생성한다.
- 루트 페이지는 Primary Key와 데이터 페이지(실질적인 데이터가 저장되는 페이지)의 주소를 저장한다.

### 클러스터링 인덱스 적용 방법
- 데이터를 삽입 한 뒤 Primary Key 제약 조건을 걸어준다.
- 데이터를 삽입 한 뒤 NOT_NULL과 UNIQUE 제약 조건을 동시에 걸어준다.
  
### 클러스터링 인덱스 정리
- 실제 데이터 자체가 정렬된다.
- 테이블당 1개만 존재할 수 있다.
- 리프 페이지 = 데이터 페이지
- 아래의 제약조건 시 자동 생성
  - primary key (우선순위)
  - unique + not null

### 논-클러스터링 인덱스(보조, 세컨더리 인덱스)
- 실제 데이터와 다른 무리의 별도의 인덱스를 의미한다.
- 실제 데이터를 저장하고 있는 데이터 페이지에는 어떠한 정렬이나 변경이 발생하지 않는다.
- 별도의 인덱스 페이지(리프 페이지)가 추가된다.
  - 인덱스가 설정된 데이터를 기준으로 정렬된다.
  - 인덱스가 적용된 데이터와 해당 데이터가 실제로 존재하는 데이터 페이지의 주소 + 해당 페이지에서의 위치를 담고있다.
  - ex. 1002(데이터 페이지의 주소) + #3(해당 데이터 페이지에서의 위치)

#### 논-클러스터링 인덱스 적용 방법
- 테이블에 UNIQUE 제약 조건을 건다.
- 인덱스를 직접 생성한다.

#### 논-클러스터링 인덱스 정리
- 실제 데이터 페이지는 건드리지 않는다.
- 별도의 인덱스 페이지를 생성한다. (리프 페이지 - 추가 공간이 필요하다.)
- 테이블당 여러 개가 존재할 수 있다.
- 리프 페이지에 실제 데이터 페이지 주소를 담고 있다.
- unique 제약 조건을 적용하면 자동으로 생성된다.
- 직접 index를 생성하면 논-클러스터링 인덱스가 생성된다.

### 클러스터링 인덱스와 논-클러스터링 인덱스를 함께 적용하면 어떻게 될까?
- id 컬럼에는 클러스터링 인덱스를 적용
- name 컬럼에는 논-클러스터링 인덱스를 적용
- 이렇게 설정하면 리프 페이지에는 name 컬럼의 데이터(key)와 id 컬럼의 데이터(value)가 그대로 저장된다. (별도의 페이지 주소 값이 저장되지 않는다.)
- 예를들어 '라라'라는 이름을 검색한다고 가정한다면 어떤 프로세스로 동작할까?
  - name 인덱스 페이지에서 '라라'를 조회한다.
  - '라라'에 해당하는 id 데이터를 확인하고 id 인덱스 페이지로 가서 id 데이터의 데이터 페이지 주소 값을 조회한다.
  - 데이터 페이지의 주소값과 id 데이터를 활용하여 원하는 데이터를 조회한다.

#### 논-클러스터링 인덱스가 적용된 컬럼의 인덱스 페이지에서는 왜 주소 값을 사용하지 않을까?
1. 데이터를 추가한다.
2. 페이지 분할이 일어난다.
3. 기존 인덱스 페이지의 주소(value) 값이 바뀐다.

이처럼 데이터 추가 및 변경 시 논-클러스터링 인덱스 페이지의 주소 값도 변경시켜줘야하는 문제가 발생한다. 
  
> 클러스터링 인덱스가 적용된 컬럼의 인덱스 페이지에서는 주소 값을 변경시켜주지 않아도 된다. 루트 페이지 주소는 그대로 유지되고, 페이지 분할이 일어나 새롭게 생성된 페이지의 루트 페이지 주소 값만 추가해주면 되기 때문이다.

## 인덱스 적용 기준
어떤 컬럼에 인덱스를 적용해야 할까?
- 카디널리티가 높은 컬럼
- WHERE, JOIN, ORDER BY 절에 자주 사용되는 컬럼
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 규모가 작지 않은 테이블

### 카디널리티
그룹 내 요소의 개수를 의미한다. 인덱스를 적용할 때는 카디널리티가 높은 것을 기준으로 해야한다. 카디널리티가 높다는 뜻은 중복 수치가 낮음을 의미한다.

## 인덱스 사용 시 주의사항
- 잘 활용되지 않는 인덱스는 과감히 제거하는 것이 좋다.
  - WHERE 절에서 사용되더라도 자주 사용해야 가치가 있다.
  - 불필요한 인덱스로 오히려 성능 저하가 발생할 수 있다.
- 데이터 중복도가 높은 컬럼은 인덱스 효과가 적다.
- 자주 사용되더라도 INSERT / UPDATE / DELETE가 자주 일어나는지 고려해야 한다.

## 복합 인덱스
데이터 베이스에서 여러개의 컬럼들을 조합하여 인덱스를 생성하는 방식이다.

### 복합 인덱스 장점
- 여러 개의 컬럼을 동시에 검색할 수 있기 때문에 검색 속도가 개선된다.
- 데이터 정렬의 효율성이 향상된다.
- 인덱스의 용량이 절감된다.
- 쿼리가 여러 개의 조건을 갖고 있을 때 굉장히 효율적이다.

### 복합 인덱스 컬럼 선택 조건
- WHERE 절에서 AND 조건으로 자주 통합되어 사용되는 컬럼
- AND 조건으로 묶어서 사용할 때 분포도가 더 좋아지는 컬럼들
- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
- ORDER BY에서 자주 사용되는 컬럼들
- 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

> **분포도가 좋다는 것은 무슨 의미인가?** <br />
> 서로 다른 데이터가 중복도가 적은 상태로 존재한다는 뜻이다.

### 복합 인덱스 사용 시 주의점
- 인덱스를 생성할 때 WHERE절의 순서와 일치시키는 것이 검색 효율 향상에 도움이 된다.
- 주로 자주 이용되는 순서대로 복합 인덱스 컬럼의 순서를 결정한다.

#### 복합 인덱스 생성
```
CREATE INDEX index_name ON table_name (column1, column3, column2)
```

#### 복합 인덱스가 적용된 쿼리문
```
SELECT * FROM table_name WHERE column1 = 'value1'
SELECT * FROM table_name WHERE column1 = 'value1' AND column3 = 'value3'
SELECT * FROM table_name WHERE column1 = 'value1' AND column3 = 'value3' AND column2 = 'value2'
```

#### 복합 인덱스가 적용되지 않은 쿼리문
```
SELECT * FROM table_name WHERE column2 = 'value2'
SELECT * FROM table_name WHERE column2 = 'value2' AND column3 = 'value3'
SELECT * FROM table_name WHERE column3 = 'value3' AND column2 = 'value2'
```