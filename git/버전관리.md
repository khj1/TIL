# Git
## 버전관리란?
버전이란 유의미한 변화가 하나의 결과물이 되는 것을 의미한다.
- 버전이 만들어지는 과정에선 협업이 이루어지는 경우가 대부분이다.
- 하나의 버전이 관리되는 과정에서 필요에 따라 이전 버전으로 되돌리는 과정이 필요하다.
- 하나의 버전이 관리되는 과정에서 효율적인 백업이 필요하다.

<br>

이 모든 작업을 git을 통해 편리하게 수행할 수 있다.

## 버전이 되기까지 거쳐가는 세 개의 공간
### Working directory
- 내가 코드 작업을 하는 공간
- 파일들이 생성/수정/삭제되는 공간
- 변경사항이 생기는 공간
- Working directory의 모든 변경사항들을 버전으로 만들어야할까?
  - 변경사항들 중 다음 버전이 될 파일들을 선별해서 선별된 파일들을 버전으로 만들면된다.

<br>

### Staging Area
- 버전이 될 후보들이 올라오는 공간
- Working directory에서 선별한다

<br>

### Repository
- 지금까지 만들어진 버전들이 저장되는 공간
  
<br>

## Github
`$git commit` 명령어를 통해 버전을 만들면 내 컴퓨터 속 저장소 ( 로컬 저장소 )에만 저장된다. <br>
다른 사람과 원격으로 협업하기 위해선 **Github**를 활용해야한다.

### push
Github에 코드를 업로드한다. ( git에 push한다. ) <br>
push를 하는 경우 마지막에 수정한 파일 하나만 저장되는게 아니라 지금까지 `commit`했던 내역들, 모든 버전들, 모든 변경사항들이 저장된다.( `.git` 폴더에 `commit`된 내용들이 모두 저장됨)

- `git remote add origin <github URL>`
- `git branch -M main`
- `git push -u origin main`
  - 로컬 저장소의 `main` 브랜치에서 원격 저장소인 `origin` 브랜치로 `push` 한다는 의미
  - 앞으로 `main` -> `origin`으로 푸쉬되는 것을 기본값으로 사용한다는 의미이다.

<br>

### reset
- 수정된 내용까지 통쨰로 리셋: `$git reset --hard HEAD^`
- `add`한 것 까지 리셋: `$git reset --mixed HEAD^`
- `commit` 한것만 리셋: `$git reset --soft HEAD^`

reset 명령어는 최대한 혼자만 작업하는 공간 ( feature 브랜치또는 fork 저장소 )에서만 사용하는 것을 권장한다.

<br>

#### HEAD^
- `HEAD`: 현재 작업중인 브랜치/커밋 중 가장 최근 커밋을 가리킨다.
- `^`: 하나 되돌린다는 의미이다.
- `$git reset --hard HEAD^^`: 가장 최근 커밋으로부터 2개 전으로 되돌려라.

<br>

### reset 이후 다시 돌아가는 방법
`ORIG_HEAD`를 확인하여 되돌리는 방법과 `git reflog` 를 이용하는 방법이 있다. <br>

#### ORIG_HEAD
`reset` 전의 커밋은 `ORIG_HEAD`라는 이름으로 참조할 수 있다. <br>
`ORIG_HEAD`로 되돌아가는 명령어를 치게 되면, `reset`하기 전으로 되돌아갈 수 있습니다
- `$ git reset --hard ORIG_HEAD`

<br>

#### git reflog
`git reflog`를 통해 수정 삭제된 커밋의 내역들을 볼 수 있다. <br>
이 명령어를 통해 되돌리기 전의 커밋 해시값을 확인한 후 그 해시값으로 되돌아가면 된다.
- `$ git reflog`
- `$ git reset --hard <해시값>`

<br>

***
## git 협업의 원리
1. 작업 단위로 나눈다.( branch )
2. 각자 작업한다.
3. 합친다.

<br>

### branch 관련 명령어
- `git branch`: 브랜치 목록 확인
- `git branch <브랜치이름>`: 새로운 브랜치 생성
- `git branch -d <브랜치이름>`: 브랜치를 삭제한다.
- `git checkout <브랜치이름>`: 해당 브랜치로 switch
- `git merge <브랜치이름>`: 현재 브랜치와 합치고 싶은 브랜치 이름을 작성
- `git checkcout -b <브랜치이름>`: newbranch라는 새로운 브랜치를 생성함과 동시에 해당 브랜치로 이동

## 원격 저장소
### $git remote (-v)
내 로컬 repository와 상호작용하고 있는 (혹은 할 수 있는) 원격 저장소들의 목록을 조회한다.

<br>

- `-v` 옵션: 단축이름과 URL 같이보기

<br>

### $git remote add origin \<url>
\<url>에 있는 원격 저장소를 `origin` 이라는 이름으로 추가한다.
- `$git remote add hanjun \<url>` 으로 추가해도 된다.

<br>

### $git push -u origin master
- 내 로컬 저장소의 내용을 원격 저장소에 저장할때 push 한다.
- `-u` 디폴트 설정
  - 앞으로 `$git push`만 작성해주면 알아서 origin과 master의 상호작용으로 이해한다.

<br>

### $git pull (origin master)
- origin을 내 repository의 master 브랜치로 갖고와라( merge )

<br>

### $git fetch (origin master)
- 동기화시키지는 말고 ( merge는 하지 말고 )
- `origin`을 내 `repository`의 `master` 브랜치로 일단 갖고온다.

<br>

### $git clone \<url>
\<url>에 있는 원격 저장소의 내용을 현재 디렉토리에 복사해오기

<br>

### $git remote rm <단축이름>
로컬 저장소와 연결된 원격 저장소를 제거한다.

<br>

## pull과 fetch
### pull
원격 저장소로부터 가져와서 로컬 브랜치와 합치기

<br>

### fetch
원격 저장소로부터 일단 가져만 오기

<br>

#### fetch한 내용을 확인할 수 있는 방법
1. `$git checkout origin(원격저장소 단축이름)/master(원격 저장소의 브랜치)`
   - 해당 코드를 작성해주면 로컬 저장소의 파일을 열었을때 내용을 확인할 수 있다.
2. `$git checkout FETCH_HEAD(fetch 해온 내용의 HEAD)`

<br>

***
## 협업 시나리오
1. 내 로컬 저장소는 변했는데 원격 저장소는 변함이 없는 경우
   - `$git push`
2. 내 로컬 저장소는 변함이 없는데 원격 저장소는 변한 경우
   - `$git pull`로 동기화 후 `push`하기
3. 내 로컬 저장소도 변했는데 원격 저장소도 변한 경우
   - `rebase`
   - `pull request`( PR이후 `merge` ) 

<br>

### 만약 push 또는 pull을 하려는데 해당 파일을 github 내에서 직접 작업하고 있다면?
`reject`에러가 발생한다. ( `conflict` ) <br>
이렇게되면 `push` 또는 `pull` 이후에 소스코드가 이상하게 변한다

    >>>> HEAD
    <내가 작성한 코드>
    ----------
    <다른 사람이 동시에 작업하고 있던 코드>
    >>>> <커밋 해시값>

`merge`하기 전에 개발자가 직접 어떤 코드를 사용할지 정하도록 한다.

<br>

### Pull Request
1. 협업 대상 `repository fork` 하기
2. `fork` 해온 곳에서 `clone` 하기
3. `branch`를 만들고 작성하고자 하는 코드( `commit` ) 작성
4. 여기서 `add`, `commit`, 새로만든 `branch`에 `push` 한다
5. `pull request` 보내기
6. 새롭게 만들었던 `branch` 지우기

<br>

***
## Git의 원리
### Git에서의 커밋이란?
1. 변경사항의 모음이 아니라 **하나의 최종 코드의 모음이다.**
2. 다만 기존 커밋과 비교해서 변경된 파일이 아니면 변경되지 않았다고만 저장해서 용량이 무겁지 않다.

   - git 이전의 버전관리 시스템인 SVN은 바로 이전 커밋과의 변경사항만 저장했다.
   - 그래서 커밋당 용량은 더 가볍지만 한 버전을 보려면 맨 처음 커밋부터 계산해야한다.
   - Git은 바로 이전 커밋만 보면된다. ( 속도가 훨씬 빠름 )

<br>

### Git으로 추적하는 파일의 4가지 형태
- `untracked` : 추적 안됨
- `tracked` : 추적 됨
  - 수정 없음
  - 변경됨
  - 스테이지 됨
- 작업 공간에 있는 수정함, 추적 안됨 파일을 스테이지로 올려 스테이지 됨 상태로 변경한다.
- 커밋을 하면 수정 없음 상태로 돌아가서 다시 파일을 수정할 수 있다.

<br>

### 브랜치
브랜치는 보통 새로운 기능을 추가할 때 만들어준다. 

### Squash and merge
**Squash and merge** 에서 `squash`는 여러 개의 커밋을 하나로 합치는 기능을 말한다. <br>
즉 **Squash and merge** 에서 발생하는 머지 커밋은 실질적인 머지로 인해서 생성된 머지 커밋이라기보다는 **다른 브랜치의 변경 사항을 하나로 뭉쳐놓은 커밋인 것이다.**

<br>

### amend
마지막 커밋 내용에서 빠뜨린 내용이 있을 때 사용하는 명령어. <br>
**기존 커밋 내용에 덮어쓰는 개념**이기 때문에 자칫 잘못하면 협업 시 충돌 문제가 생겨 히스토리 전체가 꼬일 수 있는 문제가 있으므로 **주의해서 사용해야한다**. <br>
따라서 협업시 자기자신만 사용하는 `feature/` 브랜치 내에서만 사용하는 것을 권장한다.

<br>

> **소스트리** <br>
> 커밋을 할 때 커밋버튼을 누르고 커밋 옵션에서 **'마지막 커밋 정정'**을 선택후 커밋해주면 `amend`가 적용된다.

<br>

### stash
깃에서는 작업을하다가 다른 브랜치로 넘어갈 때 기존 작업 내용을 커밋해주지 않으면 해당 내용이 모두 날아가버리는 문제가 발생한다. <br>
따라서 급하게 다른 브랜치로 넘어가야하는 경우 해당 파일을 `stash` 명령어로 보관해주면 된다. <br><br>

> 소스트리 <br>
> 1. 상단의 `stash` 버튼 클릭
> 2. `stash` 메시지 작성해주고 확인을 누르면 WorkSpace의 변경사항들이 사라진것을 확인할 수 있다. 따라서 다른 브랜치로 넘어가도 무방하다.
> 3. 다른 브랜치에서 작업을 끝내고 `stash`로 저장해놓은 부분부터 다시 이어 작업하고 싶으면
> 4. 소스트리 좌측의 **'스태시'** 탭에 저장된 내용을 우클릭한 후 **'스태시 적용'** 버튼을 누르면 된다.( `pop` )

<br>

- ***주의! stash 기능은 tracked 상태의 파일에만 사용할 수 있다.***

<br>

### revert
잘못하고 `master` 브랜치의 내용에 잘못된 내용을 커밋했을때! <br>
`reset`을 해버리면 협업하고 있는 사람들에게 불편을 끼칠 수 있으므로 `revert`를 사용하는 것이 좋다. <br>
`revert`는 **커밋을 되돌리되 기존 커밋을 초기화하지 않고 새로운 커밋을 만들면서 잘못된 커밋을 하기 전의 코드로 되돌아가는 것을 의미한다.**

<br>

> 소스트리 <br>
> `HEAD`에서 우클릭 후 **커밋 되돌리기** 버튼 클릭

<br>

### cherry-pick
- 다른 브랜치의 기능중에 원하는 기능만 가져와서 현재 작업 브랜치에 삽입하는 방법이다.

