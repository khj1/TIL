# 운영체제란 무엇인가?

- 컴퓨터 하드웨어 바로 윗단에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.
- 커널은 운영체제의 핵심 부분으로 메모리에 상주하는 부분이다. (운영체제의 좁은 의미)
- 커널 뿐만 아니라 각종 주변 시스템 유틸리티를 포함한 개념 (운영체제의 넓은 의미)

## 운영체제의 구성 요소

- 커널
    - 운영 체제의 핵심 부분
        - 커널은 C언어와 같은 프로그래밍 언어로 개발된 소프트웨어다.
        - 하드웨어와 소프트웨어의 중간 역할을 수행한다.
        - 사용자와 직접 상호작용하진 않는다.
- 쉘
    - 사용자가 운영체제와 상호작용할 수 있도록 제공되는 인터페이스(CLI, GUI)
- 유틸리티 프로그램
    - 파일 관리, 네트워킹, 시스템 모니터링
- 라이브러리 및 서비스
    - 응용 프로그램이 운영체제 기능을 쉽게 사용할 수 있도록 돕는 인터페이스

> 운영체제를 자동차라고 한다면 커널은 엔진이다. 나머지 부품들은 사용자가 자동차를 쉽게 운전할 수 있도록 돕는 부품들이다.

## 운영 체제의 목적

- 가장 중요한 역할은 컴퓨터 시스템의 자원(CPU, 메모리, 입출력 장치)을 효율적으로 관리하는 것이다.
    - 사용자 간의 형평성 있는 자원 분배가 이루어지도록 한다.
    - 주어진 자원으로 최대한의 성능을 내도록 한다.
    - 하드웨어 자원(프로세서, 기억장치, 입출력 장치) 뿐만 아니라 소프트웨어 자원(프로세스, 파일, 메시지 등)을 효율적으로 관리 할 의무가 있다.
- 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다.
    - 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공한다.
    - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행한다.

## 운영 체제의 분류

- **동시 작업 가능 여부**
    - single tasking
        - MS-DOS
    - multi tasking
        - 현대의 운영체제들은 모두 멀티 태스킹을 지원한다.
        - 동시에 두 개 이상의 작업 처리
        - 한 명령의 수행이 끝나기 전에 다른 명령이나 다른 프로그램을 실행할 수 있음
- **사용자의 수**
    - single user
    - multi user
        - 하나의 컴퓨터를 다수의 사용자가 동시에 사용할 수 있다.
- **처리 방식**
    - 일괄 처리(Batch Processing)
        - 작업 요청을 모아 한꺼번에 처리한다.
        - 작업이 완전 종료될 때까지 기다려야 한다.
    - 시분할(Time Sharing)
        - 여러 작업이 짧은 시간 단위로 CPU를 공유한다.
        - 현대의 OS가 사용하는 처리 방식이다.
    - 실시간(Realtime OS)
        - 정해진 시간 내에 작업이 완료되어야 한다. (매우 정교한 시스템이다.)
        - ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로봇 제어
            - Hard realtime system
            - Soft realtime system

### 용어

- 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻하는 용어들
- Multitasking
- Multiprogramming
    - 여러 프로그램이 메모리에 올라가 있음을 강조하는 개념이다.
- Time sharing
    - CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조한다.
- Multiprocess(다중 CPU)
    - 하나의 컴퓨터에 CPU(processor)가 여러개 붙어있음을 의미한다.

## System Structure, Program Execution

- 컴퓨터 시스템은
    - **CPU**와 **메모리**로 구성되어있는 컴퓨터(Host)
    - **I/O device**들로 이루어져 있다.
        - disk, 키보드, 프린터, 모니터
        - 각 I/O Device 에는 입출력 장치를 관리하는 작은 CPU 가 붙어있다. (**device controller**)
        - CPU의 작업공간인 메모리가 필요하듯 각 컨트롤러도 작업 공간이 따로 필요하다. (**local buffer**)
- **Memory**는 CPU의 작업 공간이다.
- CPU 내부에는 메모리보다 더 빠르면서 정보를 저장할 수 있는 작은 공간이 있다. (**register**)
    - CPU를 실행하고 있는 것이 OS 인지, 사용자 프로그램인지 구분하게 해주는 것이 **mode bit** 이다.
    - CPU는 항상 메모리에 있는 instruction만 실행하는 운명이다.
        - CPU가 메모리에 있는 특정 작업을 수행하다가 입출력 장치로 부터 데이터를 받아와야 한다면?
        - CPU가 입출력 장치에 붙어있는 컨트롤러에게 해당 데이터를 받아와 달라고 지시한다.
        - 디스크는 CPU 보다 100만배 이상 느리기 때문에 CPU 는 device controller 가 작업을 수행하는 동안 다른 작업을 수행한다.
        - 외부 하드웨어 장치(입출력 장치)가 작업을 모두 완료하면 CPU의 주의를 끌기 위해 인터럽트 신호를 보낸다.
        - Interrupt Line 은 인터럽트 신호를 보내는 경로를 의미한다.
        - 인터럽트 된 CPU는 현재 작업을 중단하고 해당 이벤트를 처리한다.
        - 이는 특정 작업이 끝날 때까지 기다리지 않고 동시성을 구현하는 데 필수적이다.
            - 인터럽트 라인은 쉽게 말하자면 긴급 호출 벨이라고 보면 된다.
            - CPU가 기존 작업을 중단하고 더 중요한 작업을 즉시 수행할 수 있도록 만든다.
        - CPU는 하나의 Instruction을 끝내면 인터럽트 라인을 확인한다.
    - Timer 는 특정 프로그램이 CPU 를 독점하는 것을 막기 위해 존재한다.
        - 특정 프로그램이 너무 오랫동안 CPU를 점유하면 타임 인터럽트를 발생시킨다.
        - 인터럽트를 받은 CPU는 기존 작업을 중단한다.
        - CPU의 제어권이 사용자 프로그램으로부터 OS로 넘어간다.
        - OS는 기다리고 있던 다른 프로그램이 CPU를 사용할 수 있도록 CPU 제어권을 넘긴다.
    - 사용자 프로그램은 스스로 입출력 장치에 직접 접근할 수 없다.
        - 사용자 프로그램이 입출력 장치에 접근하기 위해선 반드시 OS를 거쳐야 한다.
        - 그러면 프로그램이 스스로 CPU 제어권을 OS에 넘겨주고 운영체제가 해당하는 작업을 I/O Controller에 지시한다.

### Mode bit

- CPU를 실행하고 있는 것이 OS 인지, 사용자 프로그램인지 구분하게 해주는 것이 **mode bit** 이다.
    - Mode bit 은 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영 체제에 피해가 가지 않도록 하기 위한 보호장치다.
    - Mode bit 을 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다.
    - `1` 사용자 모드: 사용자 프로그램 수행
        - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit 을 1로 셋팅한다.
        - mode bit 이 1 일때는 제한된 Instruction만 수행할 수 있다.
    - `0` 모니터 모드: OS 코드 수행
        - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행할 수 있다.
        - Interrupt나 Exception이 발생하면 하드웨어가 mode bit 을 0 으로 바꾼다.

### device controller

- 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
- 제어 정보를 위해 control register, status register 를 가진다. (CPU의 작업 지시를 수행)
- local buffer 를 가진다 (일종의 data register)
- I/O 는 실제로 device 와 local buffer 사이에서 일어난다.
- device controller 는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알린다.

> device driver (장치 구동기) </br>
> OS 코드 중 각 장치별 처리 루틴을 의미한다. (software) </br>
> OS 가 각 장치를 손쉽게 다룰 수 있도록 하는 인터페이스와 같다 </br>
> CPU 가 disk 에 작업을 지시할 때 필요한 코드를 담고 있다. (인터럽트 처리 루틴도 이에 포함되어있다.)

### DMA(direct memory access) controller

- 원래는 메모리에 직접 접근할 수 있는 장치는 CPU 뿐이다.
- DMA Controller 도 메모리에 접근할 수 있게 만들었다.
    - 메모리에 CPU 와 DMA Controller 가 동시에 접근하면 문제가 발생할 수 있기 때문에 중간에 Memory Controller 를 두었다.
- I/O 장치가 너무 자주 Interrupt 를 걸면 CPU 의 작업이 너무 느려질 수 있다.
- I/O 장치의 작업이 끝나고 local buffer 에 해당 결과물이 담겨있으면 DMA Controller 가 메모리에 그 데이터를 copy 해서 전달해주는 역할을 수행한다.
- 그 이후 DMA Controller 가 CPU 에 인터럽트를 한번만 걸어서 작업 완료 보고를 한다.
    - 기존 Device controller 는 데이터를 한 바이트 또는 한 워드 단위로 전송한다.
    - 디바이스가 다음 데이터를 준비할 때마다(데이터를 전송할 때 마다) 다시 인터럽트를 발생시키기 때문에 문제가 된다.
    - 반면 CPU는 DMA 컨트롤러에게 한번에 전송해야할 데이터의 시작 주소와 크기, 전송 방향을 명령한다.
    - 이후 DMA 컨트롤러가 메모리와 디바이스 간의 데이터 전송을 직접 수행한다.
    - 전송이 완료되면 단 한번의 인터럽트를 통해 CPU에 알린다.
        - 데이터 전송 과정에서 CPU가 관여하지 않는 장점이 있다.
        - CPU는 데이터를 직접 전송하는 대신 다른 작업을 수행할 수 있다.
    - 만약 1KB 의 데이터를 전송한다고 가정해보면
        - device controller: 1 바이트당 1회 -> 1024 번 인터럽트 발생
        - DMA controller: 1회 전송 후 1회 인터럽트 -> 1 번 인터럽트
    - 대용량의 데이터를 처리하는 경우 성능에 큰 차이를 만든다.
    - 또한 Device controller 기반의 인터럽트는 CPU가 모든 데이터 전송 요청을 처리해야 하므로 컨텍스트 스위칭 비용이 많이 든다.
- DMA Controller의 핵심은 기존 CPU 가 직접 수행하던 데이터 전송 작업을 DMA Controller 가 분담하여 CPU 의 성능과 효율성을 향상시키는 것이다.
- Interrupt driven I/O 방식에서는 local buffer 에 데이터를 채우거나 비우는 과정에서 CPU 가 개입해야하기 때문에 인터럽트가 자주 발생했다.
- DMA 방식을 사용할 때라도 Device Controller 가 CPU에게 직접 인터럽트를 발생시킬 수 있다.
    - 주로 초기 요청(데이터 전송 준비 완료)시에만 인터럽트를 직접 발생시킨다.
    - 그러면 CPU가 DMA 컨트롤러에게 작업을 지시하고 이후로는 Device Controller 가 직접 CPU 에게 인터럽트를 보내는 일이 없다.
- DMA Controller 는 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킨다.

### I/O의 수행

- 모든 입출력 명령은 특권 명령이다. (mode bit 0 일때만 가능)
- 사용자 프로그램은 어떻게 I/O를 하는가?
    - system call
        - 사용자 프로그램이 운영체제에게 I/O 요청을 한다.
    - trap 을 사용하여 인터럽트 벡터의 특정 위치로 이동한다.
    - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동한다.
    - 올바른 I/O 요청인지 확인 한 후 I/O 를 수행한다. (권한 확인)
    - I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮긴다.
    - 결국 I/O 요청에는 trap이, I/O 응답에는 interrupt 가 발생한다고 보면 된다.

### 인터럽트

- 인터럽트 당한 시점의 레지스터와 Program counter 를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다,
- Interrupt
    - 하드웨어가 발생시킨 인터럽트
    - Device Controller 가 발생시킨 인터럽트
    - Timer Interrupt
- Trap
    - 소프트웨어가 발생시킨 인터럽트
    - Exception
    - System call
        - 프로그램이 커널 함수(OS)를 호출하는 경우
- 인터럽트 벡터
    - 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
        - 키보드 인터럽트가 발생하면 어디로 가야하고
        - 모니터 인터럽트가 발생하면 어디로 가야하는지
- 인터럽트 처리 루틴
    - 해당 인터럽트를 처리하는 커널 함수
    - 인터럽트를 받았을 때 CPU 가 실제로 처리해야 하는 함수다.

### PC Register

- CPU 는 메모리의 Instruction 을 실행한다.
- 메모리의 어떤 위치에 있는 Instruction 을 실행하는가?
- register 에는 메모리 주소를 가리키고 있는 Program Counter Register 가 있다. (PC register)
- CPU 가 Instruction 을 수행하면 PC Register 는 다음 주소를 가리키게 된다.

## 동기식 입출력과 비동기식 입출력

- synchronous I/O
    - I/O 요청 후 입출력 작업이 완료된 후에야 CPU 제어가 사용자 프로그램에 넘어감
    - 구현 방법 1
        - I/O 가 끝날 때 까지 CPU 를 낭비시킴
        - 매 시점 하나의 I/O 만 일어날 수 있음, 다른 I/O 장치도 낭비가 된다.
    - 구현 방법 2
        - I/O 가 완료될 때 까지 해당 프로그램에게서 CPU 를 빼았는다.
        - I/O 처리를 기다리는 줄(line)에 그 프로그램을 줄 세운다.
        - 다른 프로그램에게 CPU 를 준다.
- asynchronous I/O
    - I/O 가 시작된 후 입출력 작업이 끝날 때 까지 기다리지 않고 제어가 **해당 사용자 프로그램에** 즉시 넘어간다.
    - 해당 프로그램은 I/O 가 진행되든 말든 다른 작업을 이어나갈 수 있다.
- 두 경우 모두 인터럽트로 I/O 가 끝났음을 알려준다.

### 서로 다른 입출력 명령어

- I/O 를 수행하는 special Instruction 에 의한 입출력 (Isolated I/O)
    - 메모리 주소 공간과 I/O 장치가 서로 별도의 주소 공간을 사용한다.
    - 특별한 I/O 명령어가 필요하다. (`IN`, `OUT` 등)
- Memory Mapped I/O 에 의한 입출력
    - 하드웨어 장치를 메모리 주소 공간에 매핑하여 CPU 가 메모리처럼 장치를 제어할 수 있도록 하는 방식이다.
    - I/O 장치와 메모리 간 구분이 없고, CPU 는 메모리 접근 명령을 사용해 장치와 상호작용 할 수 있다.
    - ex) 특정 메모리 주소를 읽는 행위가 사실은 키보드 입력을 읽는 작업이다.
    - 별도의 I/O 명령어가 필요하지 않기 때문에 설계가 간소화된다. (예)`LOAD`와 `STORE` 와 같은 일반적인 메모리 명령어로 장치와 상호작용)
    - 하지만 메모리 주소 공간이 낭비될 수 있다.
    - 주로 고성능 시스템에 사용된다.
        - GPU, 네트워크 카드, 임베디드 시스템

## 저장 장치 계층 구조

- 휘발성 메모리, primary memory(executable - CPU 가 직접 접근할 수 있음)
    - Register
    - Cache memory
    - Main memory
- 비휘발성 메모리, secondary memory
    - Magnetic disk
    - Optical disk
    - Magnetic tape

- 밑으로 갈수록 용량이 커지고 느려지고 싸진다.

> 최근에는 메인 메모리도 비휘발성 메모리로 개발되고 있다.

## 프로그램의 실행 (메모리 load)

- 프로그램을 실행시킨다.
    - 그 프로그램의 주소 공간(Virtual Memory)이 형성된다.
    - 해당 주소 공간은 code, data, stack 영역으로 구성된다.
    - 모든 데이터가 한번에 물리적인 메모리에 할당되는 것은 낭비다.
    - 따라서 실행에 필요한 일부만 Physical Memory 에 로드되고 사용하지 않는 부분은 Disk 의 Swap Area 에 보관된다.
    - Swap Area 는 Disk 의 File System 과는 다른 개념이다.
    - File System 은 전원이 나가더라도 데이터가 소실되어선 안된다.
    - 하지만 Swap Area 는 전원이 나가면 의미가 없는 데이터가 된다. (프로세스가 종료되기 때문에)
        - Swap Area 는 같은 Disk 에 존재할 수도, 별도의 디스크에 존재할 수도 있다.
        - 고성능 서버나 특정 환경에서는 Swap Area 와 File System 을 별도의 물리 디스크에 배치하기도 한다.

- 커널도 프로그램이므로 별도의 가상 메모리가 생성된다.

#### 사용자 프로그램이 사용하는 함수

- **사용자 정의 함수**
    - 자신이 프로그램에 정의한 함수
- **라이브러리 함수**
    - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
    - 자신의 프로그램 실행 파일에 포함되어 있다.
- **커널 함수**
    - 운영 체제의 프로그램 함수
    - 커널 함수 호출 = 시스템 콜

# 프로세스

## 프로세스의 개념

- 프로세스란 실행중인 프로그램을 의미한다.
- **프로세스의 문맥**
    - CPU 수행 상태를 나타내는 하드웨어 문맥
        - Program Counter
        - 각종 register
    - 프로세스의 주소 공간
        - code, data, stack
    - 프로세스 관련 커널 자료 구조
        - PCB (Process Control Block)
            - 프로세스가 생성될 때 마다 PCB 가 할당되어 프로세스를 관리한다.
        - Kernel Stack
            - 프로세스가 작업을 수행하다 자신이 수행하지 못하는 일을 OS 에 요청하게 될 때
            - PC 가 커널 주소 공간을 가리키게 되고 커널 내부에서 함수가 호출된다.
                - 커널은 여러 프로세스가 공유하는 자원이다.
                - 하지만 커널 내부에서 함수가 호출될 때는 어떤 프로세스가 커널을 호출했는지 구분하기 위해
                - 별도의 커널 stack 을 프로세스마다 두고 있다.
                - 프로세스가 각 시스템 호출이나 인터럽트를 통해 커널에 접근할 때 커널은 각 프로세스의 작업 상태를 저장하고 복구해야 한다.
                - 이를 위해 각 프로세스는 독립적인 커널 스택을 가진다.
                - 커널 스택은 오직 커널 모드에서만 접근할 수 있다.
                - 사용자 모드 코드는 커널 스택에 직접 접근할 수 없다.
                - 커널 스택은 프로세스가 생성될 때 마다 커널 주소 공간 내부에 해당 프로세스를 위한 새로운 커널 스택을 생성한다.
- 현대의 OS 는 시분할 방식으로 작업을 처리하기 때문에 CPU 제어권이 특정 프로세스에서 다른 프로세스로 넘어갈 때 기존 프로세스의 문맥을 기억해 두어야
- CPU 제어권을 다시 받았을 때 이전 작업을 이어나갈 수 있게 된다.

## 프로세스의 상태

- **Running**
    - CPU 를 잡고 instruction 을 수행중인 상태
- **Ready**
    - CPU 를 기다리는 상태
- **Blocked**
    - CPU 를 주어도 당장 instruction 을 수행할 수 없는 상태
    - 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 이를 기다리는 상태 (ex I/O 작업)
- **New**
    - 프로세스가 생성중인 상태
- **Terminated**
    - 프로세스의 수행이 끝난 상태
- **Suspended**
    - 외부적인 이유로 프로세스의 수행이 정지된 상태
    - 프로세스는 통째로 디스크에 swap out 된다.
        - Swapper 의 등장으로 새롭게 등장한 프로세스의 상태 개념이다.
        - 메모리에 너무 많은 프로세스가 올라가서 Swapper(중기 스케쥴러)로 부터 쫓겨난 상황은 Ready 도 아니고 Blocked 도 아니다.
        - Swapper 뿐만 아니라 사용자가 프로그램을 일시 정지시킨 경우에도 Suspended 상태가 된다. (외부적인 이유)
- Blocked vs Suspended
    - Blocked: 자신이 요청한 event 가 만족되면 Ready 상태로 전환된다.
        - 기본적으로 Blocked 라도 프로세스 자체가 멈춰버린것은 아니므로 Active 상태다.
    - Suspended: 외부에서 resume(메모리에 다시 올려주면) 해주면 Active
        - Suspended Blocked
            - 프로세스가 대기 조건(I/O 작업, 특정 이벤트 발생 등)을 기다리며 Blocked 된 상태였지만 메모리에서 제거된 상태다
        - Suspended Ready: 이벤트가 발생하거나 입출력 작업이 끝나면 Suspended Ready 상태로 전환된다.
            - 프로세스가 메모리에 적재되진 않았지만 대기 조건이 해소되어 실행 준비가 완료된 상태를 의미한다.
        - Suspended 상태 자체가 프로세스가 얼어붙은 inactive 상태를 뜻한다.
    - 예시
        - 프로세스 A 가 디스크에서 데이터를 읽어오는 작업을 요청한다.
        - 데이터를 받아올 때 까지 Blocked 상태가 된다.
        - 메모리에 너무 많은 프로세스가 올라가서 프로세스 A 가 Swap out 된다.
        - 메모리에서 제거되었기 때문에 Suspended Blocked 상태가 된다.
        - 디스크 I/O 작업이 끝나면, A 의 대기 조건이 해소되므로 Suspended Ready 상태로 전환된다.
        - 운영체제가 프로세스를 다시 메모리에 적재하면 A 는 Ready 상태가 되어 실행될 준비를 한다.

## PCB

- 운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보
- 구성 요소
    - OS 가 관리상 사용하는 정보
        - process state
        - process ID
        - scheduling information
        - priority
    - CPU 수행 관련 하드웨어 값
        - program counter
        - registers
    - 메모리 관련
        - code, data, stack 의 위치 정보
    - 파일 관련
        - open file descriptors

## 컨텍스트 스위치

- CPU 를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- 컨텍스트 스위칭 간 운영체제는 다음과 같은 작업을 수행한다.
    - CPU 를 내어주는 프로세스 상태를 그 프로세스의 PCB 에 저장한다.
    - CPU 를 새롭게 얻는 프로세스의 상태를 PCB 에서 읽어온다.
- System call 이나 Interrupt 발생시 반드시 컨텍스트 스위치가 일어나는 것은 아니다.
    - 컨텍스트 스위칭은 CPU 제어권이 사용자 프로세스에서 다른 사용자 프로세스로 넘어가는 것을 의미한다.
    - System call 이나 Interrupt 는 CPU 제어권이 사용자 프로세스에서 운영체제로 넘어가게 한다.
    - 다만 System call 이후에 타이머 인터럽트가 발생하거나, I/O 요청 처럼 오래걸리는 작업을 요청하면 CPU 제어권을 다른 프로세스로 넘긴다.
        - 이 경우 컨텍스트 스위칭이 발생한다.
- 물론 첫번째 경우도 CPU 수행 정보 등 context 일부를 PCB 에 저장해야 하지만
- 컨텍스트 스위칭이 발생하는 두번째 경우보다 그 부담이 훨씬 적다.
    - 컨텍스트 스위칭이 발생하면 캐시 메모리에 저장되어있던 기존 프로세스의 정보를 모두 flush(제거) 해줘야 한다.
    - 반면 유저모드에서 커널모드로 넘어가고 다시 유저모드로 넘어오는 상황은 flush 를 하지 않아도 된다.
    - 캐시 메모리 flush 자체가 큰 오버헤드를 발생시킨다.
        - 프로세스 A 의 데이터가 캐시 메모리에 저장되어 있다가 프로세스 B 로 컨텍스트 스위칭이 발생하면
        - 기존의 프로세스 A 의 데이터는 캐시 메모리에서 플러시 된다.
            - 캐시 메모리의 데이터가 충돌함을 방지하기 위해
        - 다시 프로세스 A 로 CPU 의 제어권이 넘어왔을 때 캐시 메모리에 프로세스 A 의 데이터가 없기 때문에 캐시 미스가 자주 발생한다.
        - 이로 인해 프로세스 A 는 다시 메인 메모리에서 직접 데이터를 읽어와야 한다.

## 프로세스를 스케쥴링하기 위한 Queue

- **Job Queue**
    - 현재 시스템 내에 있는 모든 프로세스의 집합
- **Ready Queue**
    - 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합
- **Device Queue**
    - I/O device 의 처리를 기다리는 프로세스의 집합
- 프로세스들은 각 큐들을 오가며 수행된다.
- 큐에는 실제로 프로세스가 줄을 서는 것이 아니라 PCB 가 대기한다.

## 스케쥴러

- **Long-term scheduler**(job scheduler)
    - 시작 프로세스 중 어떤 것들을 ready queue 로 보낼지 결정한다.
    - 프로세스에 memory 를 주는 문제
    - degree of Multiprogramming 을 제어한다.
        - 메모리에 프로그램을 몇 개 올릴 건지 제어한다.
    - 시분할 시스템에는 보통 장기 스케쥴러가 없다.
        - 프로세스가 시작되면 바로 메모리를 주고 ready 상태로 대기한다.
        - 하지만 메모리에 올라가는 프로세스의 수를 제어하기 위해 Swapper 를 함께 사용한다.
- **Short-term scheduler**(CPU scheduler)
    - 어떤 프로세스를 다음번에 running 시킬지 결정한다.
    - 프로세스에 CPU 를 주는 문제
    - 충분히 빨라야 한다.
- **Medium-term scheduler**(Swapper)
    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.
    - 프로세스에게서 memory 를 뺏는 문제
    - degree of Multiprogramming 을 제어한다.